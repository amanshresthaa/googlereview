generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum MembershipRole {
  OWNER
  MANAGER
  STAFF
}

enum GoogleConnectionStatus {
  ACTIVE
  REAUTH_REQUIRED
}

enum DraftOrigin {
  AUTO
  REGENERATED
  USER_EDITED
}

enum DraftStatus {
  NEEDS_APPROVAL
  BLOCKED_BY_VERIFIER
  READY
  POSTED
  POST_FAILED
}

enum JobType {
  SYNC_LOCATIONS
  SYNC_REVIEWS
  GENERATE_DRAFT
  VERIFY_DRAFT
  POST_REPLY
}

enum JobStatus {
  PENDING
  RUNNING
  RETRYING
  COMPLETED
  FAILED
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships Membership[]
}

model Organization {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships      Membership[]
  googleConnection GoogleConnection?
  locations        Location[]
  reviews          Review[]
  draftReplies     DraftReply[]
  auditLogs        AuditLog[]
  jobs             Job[]
  settings         OrgSettings?
  invites          Invite[]
}

model Membership {
  orgId     String
  userId    String
  role      MembershipRole @default(OWNER)
  createdAt DateTime       @default(now())

  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([orgId, userId])
  @@index([userId])
}

model GoogleConnection {
  id                 String                @id @default(cuid())
  orgId              String                @unique
  status             GoogleConnectionStatus @default(ACTIVE)
  googleEmail        String
  googleSub          String
  scopes             String[]

  refreshTokenEnc         String
  accessTokenEnc          String?
  accessTokenExpiresAt    DateTime?

  connectedByUserId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([googleEmail])
  @@index([googleSub])
}

model Location {
  id               String   @id @default(cuid())
  orgId            String
  googleAccountId  String
  googleLocationId String

  displayName    String
  storeCode      String?
  addressSummary String?

  enabled          Boolean  @default(false)
  lastReviewsSyncAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org     Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  reviews Review[]

  @@unique([orgId, googleAccountId, googleLocationId])
  @@index([orgId, enabled])
}

model Review {
  id            String   @id @default(cuid())
  orgId         String
  locationId    String

  googleReviewName String @unique
  googleReviewId   String

  starRating Int
  comment    String?
  createTime DateTime
  updateTime DateTime

  reviewerDisplayName String?
  reviewerIsAnonymous Boolean @default(false)

  googleReplyComment    String?
  googleReplyUpdateTime DateTime?

  mentions String[]

  currentDraftReplyId String? @unique
  currentDraftReply   DraftReply? @relation("CurrentDraft", fields: [currentDraftReplyId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  location Location     @relation(fields: [locationId], references: [id], onDelete: Cascade)
  drafts   DraftReply[]

  @@index([locationId, createTime(sort: Desc)])
  @@index([locationId, starRating])
  @@index([orgId, googleReplyComment])
}

model DraftReply {
  id        String      @id @default(cuid())
  orgId     String
  reviewId  String
  version   Int
  text      String
  origin    DraftOrigin
  status    DraftStatus @default(NEEDS_APPROVAL)

  evidenceSnapshotJson Json
  verifierResultJson   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org    Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  review Review       @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  currentForReview Review? @relation("CurrentDraft")

  @@unique([reviewId, version])
  @@index([orgId, status])
}

model AuditLog {
  id        String   @id @default(cuid())
  orgId     String
  actorUserId String

  action    String
  entityType String
  entityId  String
  metadataJson Json?

  createdAt DateTime @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, createdAt(sort: Desc)])
  @@index([actorUserId, createdAt(sort: Desc)])
}

model OrgSettings {
  orgId String @id

  tonePreset             String  @default("friendly")
  toneCustomInstructions String? @db.Text

  autoDraftEnabled          Boolean @default(true)
  autoDraftForRatings       Int[]
  bulkApproveEnabledForFiveStar Boolean @default(true)

  mentionKeywords String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model Invite {
  id        String   @id @default(cuid())
  orgId     String
  email     String
  role      MembershipRole @default(STAFF)

  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdByUserId String
  createdAt DateTime @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, email])
  @@index([orgId, expiresAt])
}

model Job {
  id        String   @id @default(cuid())
  orgId     String
  type      JobType
  status    JobStatus @default(PENDING)
  payload   Json

  // Reliability hardening:
  // - dedupKey enables DB-enforced in-flight de-duplication (partial unique index via SQL migration).
  // - lastErrorCode is a stable, non-PII code used by UI and OpenAPI docs.
  // - triggeredBy* is used for request tracing/auditing and idempotency correlation.
  dedupKey            String?
  lastErrorCode       String?
  lastErrorMetaJson   Json?
  triggeredByRequestId String?
  triggeredByUserId    String?

  runAt     DateTime @default(now())
  attempts  Int      @default(0)
  maxAttempts Int    @default(10)
  lockedAt  DateTime?
  lockedBy  String?
  lastError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  completedAt DateTime?

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([status, runAt])
  @@index([orgId, status, runAt])
  @@index([lockedAt])
  @@index([orgId, type, dedupKey])
}

model ApiIdempotencyKey {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  method    String
  path      String
  key       String
  requestHash String

  // This requestId must be replayed verbatim for idempotent replays.
  requestId String

  responseStatus  Int?
  responseBodyText String? @db.Text

  createdAt DateTime @default(now())
  expiresAt DateTime

  @@unique([orgId, userId, method, path, key])
  @@index([expiresAt])
  @@index([orgId, userId, createdAt(sort: Desc)])
}

model ApiRateLimitWindow {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  scope     String
  windowStartUtcMinute DateTime
  count     Int      @default(0)
  createdAt DateTime @default(now())

  @@unique([orgId, userId, scope, windowStartUtcMinute])
  @@index([windowStartUtcMinute])
  @@index([orgId, scope, windowStartUtcMinute])
}

model ApiBudgetDaily {
  id        String   @id @default(cuid())
  orgId     String
  scope     String
  dayIso    String
  used      Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, scope, dayIso])
  @@index([orgId, scope, dayIso])
}

model ApiCooldown {
  id        String   @id @default(cuid())
  orgId     String
  scope     String
  key       String
  availableAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, scope, key])
  @@index([availableAt])
}

model ApiCircuitBreaker {
  id        String   @id @default(cuid())
  orgId     String
  upstreamKey String

  // "CLOSED" | "OPEN" | "HALF_OPEN"
  state     String
  openUntil DateTime?

  // Rolling fixed window (2m) starting at windowStartUtc.
  windowStartUtc DateTime?
  windowFailures Int @default(0)

  // Half-open success counter.
  halfOpenSuccesses Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, upstreamKey])
  @@index([orgId, state])
  @@index([openUntil])
}
