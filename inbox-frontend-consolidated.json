{
  "generatedAt": "2026-02-16T23:19:16.804Z",
  "route": "/inbox",
  "root": "/Users/amankumarshrestha/LapenInns Project/googlereview",
  "scope": "app/(app)/inbox",
  "notes": [
    "This artifact consolidates the current inbox frontend source files under app/(app)/inbox.",
    "It intentionally excludes backend API routes and server-only modules outside the inbox route directory."
  ],
  "fileCount": 10,
  "files": [
    {
      "path": "app/(app)/inbox/components/InboxDetailPanel.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/components/InboxDetailPanel.tsx",
      "bytes": 25093,
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { AnimatePresence, motion } from \"framer-motion\"\nimport {\n  AlertTriangle,\n  ArrowLeft,\n  CheckCircle2,\n  Copy,\n  History,\n  Inbox,\n  Loader2,\n  MapPin,\n  RefreshCw,\n  Save,\n  Send,\n  ShieldCheck,\n  Sparkles,\n  Star,\n} from \"lucide-react\"\nimport { toast } from \"sonner\"\n\nimport { InlineError } from \"@/components/ErrorStates\"\nimport { Button } from \"@/components/ui/button\"\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"@/components/ui/tooltip\"\nimport { INBOX_THEME_CLASSES, inboxStarClass } from \"@/lib/design-system/inbox-theme\"\nimport { formatAge, type ReviewDetail, type ReviewRow } from \"@/lib/hooks\"\nimport { cn } from \"@/lib/utils\"\n\ntype DetailAction = \"generate\" | \"save\" | \"verify\" | \"publish\"\nconst ICON_STROKE = 2.6\n\ntype InboxDetailPanelProps = {\n  row: ReviewRow | null\n  detail?: ReviewDetail | null\n  detailLoading?: boolean\n  showMobileBack?: boolean\n  onBack?: () => void\n  onGenerate: (reviewId: string) => Promise<void>\n  onSave: (reviewId: string, text: string, options?: { silent?: boolean }) => Promise<void>\n  onVerify: (reviewId: string) => Promise<void>\n  onPublish: (reviewId: string, text: string, row: ReviewRow) => Promise<void>\n}\n\nconst bubbleVariants = {\n  hidden: { opacity: 0, y: 14 },\n  visible: { opacity: 1, y: 0 },\n  exit: { opacity: 0, y: -8 },\n}\n\nfunction StarRow({ rating }: { rating: number }) {\n  return (\n    <div className=\"flex items-center gap-0.5\" aria-label={`${rating} stars`} role=\"img\">\n      {Array.from({ length: 5 }, (_, index) => (\n        <Star\n          key={`${rating}-${String(index)}`}\n          fill={index < rating ? \"currentColor\" : \"none\"}\n          strokeWidth={ICON_STROKE}\n          className={cn(\"h-3.5 w-3.5\", inboxStarClass(index < rating))}\n        />\n      ))}\n    </div>\n  )\n}\n\nfunction ReviewerAvatar({ name }: { name: string | null }) {\n  const initials = (name ?? \"A\")\n    .split(\" \")\n    .map((word) => word[0])\n    .slice(0, 2)\n    .join(\"\")\n    .toUpperCase()\n\n  return (\n    <div className=\"grid h-10 w-10 shrink-0 place-items-center rounded-2xl border border-white/68 bg-white/82 text-[11px] font-black text-slate-700 shadow-[0_10px_18px_rgba(15,23,42,0.12)]\">\n      {initials}\n    </div>\n  )\n}\n\nfunction AiAvatar() {\n  return (\n    <div className=\"grid h-10 w-10 shrink-0 place-items-center rounded-2xl border border-[#1a73e8]/35 bg-[#1a73e8]/14 text-[#1a73e8] shadow-[0_10px_18px_rgba(26,115,232,0.24)]\">\n      <Sparkles className=\"h-4 w-4\" strokeWidth={ICON_STROKE} />\n    </div>\n  )\n}\n\nfunction ActionButton({\n  tooltip,\n  ariaLabel,\n  onClick,\n  disabled,\n  className,\n  children,\n}: {\n  tooltip: string\n  ariaLabel?: string\n  onClick: () => void\n  disabled?: boolean\n  className?: string\n  children: React.ReactNode\n}) {\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>\n        <Button\n          type=\"button\"\n          variant=\"ghost\"\n          size=\"sm\"\n          className={cn(\n            \"h-10 rounded-xl border border-white/22 bg-white/12 px-3 text-white/90 transition-all duration-300 hover:bg-white/22\",\n            className,\n          )}\n          aria-label={ariaLabel ?? tooltip}\n          onClick={onClick}\n          disabled={disabled}\n        >\n          {children}\n        </Button>\n      </TooltipTrigger>\n      <TooltipContent side=\"top\">{tooltip}</TooltipContent>\n    </Tooltip>\n  )\n}\n\nfunction DraftStatusChip({ status }: { status: string | null }) {\n  if (!status) return null\n\n  const config: Record<string, { label: string; className: string }> = {\n    NEEDS_APPROVAL: { label: \"Pending review\", className: \"border-[#fbbc04]/45 bg-[#fbbc04]/20 text-[#fff1bf]\" },\n    READY: { label: \"Verified\", className: \"border-[#34a853]/45 bg-[#34a853]/20 text-[#c5f3d1]\" },\n    BLOCKED_BY_VERIFIER: { label: \"Changes needed\", className: \"border-[#ea4335]/45 bg-[#ea4335]/20 text-[#ffd5d1]\" },\n    POSTED: { label: \"Published\", className: \"border-[#1a73e8]/45 bg-[#1a73e8]/20 text-[#d6e6ff]\" },\n    POST_FAILED: { label: \"Publish failed\", className: \"border-[#ea4335]/45 bg-[#ea4335]/20 text-[#ffd5d1]\" },\n  }\n  const entry = config[status] ?? {\n    label: status,\n    className: \"border-white/30 bg-white/10 text-white\",\n  }\n\n  return (\n    <span\n      className={cn(\n        \"inline-flex items-center gap-1 rounded-full border px-2.5 py-1 text-[11px] font-black uppercase tracking-[0.1em]\",\n        entry.className,\n      )}\n    >\n      {status === \"READY\" ? <ShieldCheck className=\"h-3 w-3\" strokeWidth={ICON_STROKE} /> : null}\n      {status === \"BLOCKED_BY_VERIFIER\" ? <AlertTriangle className=\"h-3 w-3\" strokeWidth={ICON_STROKE} /> : null}\n      {entry.label}\n    </span>\n  )\n}\n\nfunction DraftHistoryTimeline({\n  drafts,\n  currentDraftId,\n}: {\n  drafts: ReviewDetail[\"drafts\"]\n  currentDraftId: string | null\n}) {\n  if (drafts.length <= 1) return null\n\n  const sorted = [...drafts].sort((a, b) => b.version - a.version)\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 6 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.28 }}\n      className=\"mb-7\"\n    >\n      <div className=\"mb-2.5 flex items-center gap-1.5 text-[11px] font-semibold uppercase tracking-[0.11em] text-slate-600\">\n        <History className=\"h-3.5 w-3.5\" strokeWidth={ICON_STROKE} />\n        {drafts.length} versions\n      </div>\n      <div className=\"space-y-1.5\">\n        {sorted.slice(0, 5).map((draft) => {\n          const isCurrent = draft.id === currentDraftId\n          const updatedLabel = draft.updatedAt ? `${formatAge(draft.updatedAt)} ago` : \"Recently\"\n          return (\n            <div\n              key={draft.id}\n              className={cn(\n                \"flex items-center gap-2 rounded-2xl border px-3 py-2 text-[11px] backdrop-blur-xl\",\n                isCurrent\n                  ? \"border-white/70 bg-white/78 text-slate-800\"\n                  : \"border-white/52 bg-white/42 text-slate-700\",\n              )}\n            >\n              <span className={cn(\"h-1.5 w-1.5 rounded-full\", isCurrent ? \"bg-[#1a73e8]\" : \"bg-slate-400\")} />\n              <span className=\"font-black tracking-[-0.01em]\">v{draft.version}</span>\n              <span className=\"ml-auto text-[11px] font-medium text-slate-600\">{updatedLabel}</span>\n            </div>\n          )\n        })}\n      </div>\n    </motion.div>\n  )\n}\n\nexport function InboxDetailPanel({\n  row,\n  detail,\n  detailLoading,\n  showMobileBack = false,\n  onBack,\n  onGenerate,\n  onSave,\n  onVerify,\n  onPublish,\n}: InboxDetailPanelProps) {\n  const [text, setText] = React.useState(\"\")\n  const [busy, setBusy] = React.useState<DetailAction | null>(null)\n  const [inlineError, setInlineError] = React.useState<string | null>(null)\n\n  React.useEffect(() => {\n    setText(row?.currentDraft?.text ?? \"\")\n    setInlineError(null)\n  }, [row?.currentDraft?.text])\n\n  const runAction = React.useCallback(async (action: DetailAction, work: () => Promise<void>) => {\n    setInlineError(null)\n    setBusy(action)\n\n    try {\n      await work()\n    } catch (error) {\n      setInlineError(error instanceof Error ? error.message : \"Action failed\")\n    } finally {\n      setBusy(null)\n    }\n  }, [])\n\n  const copyDraft = React.useCallback(async () => {\n    if (!text.trim()) return\n\n    try {\n      await navigator.clipboard.writeText(text)\n      toast.success(\"Draft copied\")\n    } catch {\n      toast.error(\"Copy failed\")\n    }\n  }, [text])\n\n  const [saveState, setSaveState] = React.useState<\"idle\" | \"saving\" | \"saved\">(\"idle\")\n  const autoSaveTimerRef = React.useRef<ReturnType<typeof setTimeout> | null>(null)\n  const lastSavedTextRef = React.useRef<string>(\"\")\n\n  React.useEffect(() => {\n    lastSavedTextRef.current = row?.currentDraft?.text ?? \"\"\n  }, [row?.currentDraft?.text])\n\n  React.useEffect(() => {\n    if (!row || busy !== null) return\n    const isDirtyFromSaved = text.trim() !== lastSavedTextRef.current.trim()\n    if (!isDirtyFromSaved || !text.trim()) return\n\n    if (autoSaveTimerRef.current) clearTimeout(autoSaveTimerRef.current)\n\n    autoSaveTimerRef.current = setTimeout(() => {\n      setSaveState(\"saving\")\n      void onSave(row.id, text, { silent: true })\n        .then(() => {\n          lastSavedTextRef.current = text\n          setSaveState(\"saved\")\n          setTimeout(() => setSaveState(\"idle\"), 2000)\n        })\n        .catch(() => {\n          setSaveState(\"idle\")\n        })\n    }, 1200)\n\n    return () => {\n      if (autoSaveTimerRef.current) clearTimeout(autoSaveTimerRef.current)\n    }\n  }, [text, row, busy, onSave])\n\n  React.useEffect(() => {\n    if (!row) {\n      setSaveState(\"idle\")\n      if (autoSaveTimerRef.current) {\n        clearTimeout(autoSaveTimerRef.current)\n        autoSaveTimerRef.current = null\n      }\n      return\n    }\n\n    setSaveState(\"idle\")\n    if (autoSaveTimerRef.current) {\n      clearTimeout(autoSaveTimerRef.current)\n      autoSaveTimerRef.current = null\n    }\n  }, [row])\n\n  const isReplied = row?.status === \"replied\"\n  const hasText = text.trim().length > 0\n  const isDirty = text !== (row?.currentDraft?.text ?? \"\")\n  const wordCount = text.trim().split(/\\s+/).filter(Boolean).length\n  const showGeneratingGlow = busy === \"generate\"\n  const currentDraftStatus = detail?.currentDraft?.status ?? row?.currentDraft?.status ?? row?.draftStatus ?? null\n  const verifyActionBlocked = currentDraftStatus === \"READY\" && !isDirty\n  const verifyDisabled = busy !== null || !hasText || verifyActionBlocked\n  const verifyTooltip = verifyActionBlocked ? \"Already verified\" : \"Tone check\"\n\n  React.useEffect(() => {\n    if (!row || isReplied) return\n\n    const handler = (event: KeyboardEvent) => {\n      const isMod = event.metaKey || event.ctrlKey\n      if (!isMod) return\n\n      if (event.key === \"Enter\" && hasText && busy === null) {\n        event.preventDefault()\n        void runAction(\"publish\", async () => {\n          await onPublish(row.id, text, row)\n        })\n      } else if (event.key === \"s\" && hasText && isDirty && busy === null) {\n        event.preventDefault()\n        void runAction(\"save\", async () => {\n          await onSave(row.id, text)\n        })\n      }\n    }\n\n    window.addEventListener(\"keydown\", handler)\n    return () => window.removeEventListener(\"keydown\", handler)\n  }, [row, isReplied, hasText, isDirty, busy, text, runAction, onSave, onPublish])\n\n  React.useEffect(() => {\n    if (!showMobileBack || !onBack) return\n\n    const handleEscape = (event: KeyboardEvent) => {\n      if (event.key !== \"Escape\") return\n      event.preventDefault()\n      onBack()\n    }\n\n    window.addEventListener(\"keydown\", handleEscape)\n    return () => window.removeEventListener(\"keydown\", handleEscape)\n  }, [onBack, showMobileBack])\n\n  if (!row) {\n    return (\n      <div className=\"flex h-full min-h-0 items-center justify-center bg-[linear-gradient(160deg,rgba(255,255,255,0.34),rgba(255,255,255,0.2))]\">\n        <motion.div\n          initial={{ opacity: 0, scale: 0.96 }}\n          animate={{ opacity: 1, scale: 1 }}\n          transition={{ duration: 0.38 }}\n          className=\"flex max-w-sm flex-col items-center gap-5 rounded-[34px] border border-white/65 bg-white/56 px-8 py-10 text-center shadow-[0_22px_60px_rgba(15,23,42,0.16)] backdrop-blur-3xl\"\n        >\n          <div className=\"grid h-20 w-20 place-items-center rounded-[28px] border border-white/70 bg-white/80 text-[#1a73e8]\">\n            <Inbox className=\"h-9 w-9\" strokeWidth={ICON_STROKE} />\n          </div>\n          <div>\n            <h3 className=\"text-[2rem] font-black tracking-[-0.03em] text-slate-900\">Select a conversation</h3>\n            <p className=\"mt-1.5 text-[15px] font-medium text-slate-700\">\n              Choose a review to open the workspace and start drafting a response.\n            </p>\n          </div>\n        </motion.div>\n      </div>\n    )\n  }\n\n  return (\n    <TooltipProvider delayDuration={280}>\n      <section className=\"relative flex h-full min-h-0 flex-col overflow-hidden bg-[linear-gradient(160deg,rgba(255,255,255,0.25),rgba(255,255,255,0.12))]\">\n        <ScrollArea className=\"h-full\">\n          <div className=\"mx-auto w-full max-w-4xl px-4 pb-56 pt-6 md:px-8 md:pb-60 md:pt-9\">\n            {showMobileBack ? (\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"sm\"\n                className={INBOX_THEME_CLASSES.detailBackButton}\n                onClick={onBack}\n              >\n                <ArrowLeft className=\"mr-1 h-4 w-4\" strokeWidth={ICON_STROKE} />\n                Back to inbox\n              </Button>\n            ) : null}\n\n            <div className=\"mb-5 flex justify-center\">\n              <div className={INBOX_THEME_CLASSES.detailLocationChip}>\n                <MapPin className=\"h-3 w-3\" strokeWidth={ICON_STROKE} />\n                {row.location.displayName}\n              </div>\n            </div>\n\n            {detailLoading ? (\n              <div className=\"mb-5 flex justify-center\">\n                <span className=\"inline-flex items-center gap-1.5 rounded-full border border-[#1a73e8]/28 bg-white/82 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.12em] text-[#1a73e8]\">\n                  <Loader2 className=\"h-3 w-3 animate-spin\" />\n                  Syncing draft history\n                </span>\n              </div>\n            ) : null}\n\n            <AnimatePresence mode=\"wait\">\n              <motion.div\n                key={`review-${row.id}`}\n                variants={bubbleVariants}\n                initial=\"hidden\"\n                animate=\"visible\"\n                exit=\"exit\"\n                transition={{ duration: 0.26, ease: [0.16, 1, 0.3, 1] }}\n                className=\"mb-7 flex items-start gap-3.5\"\n              >\n                <ReviewerAvatar name={row.reviewer.displayName} />\n                <div className=\"min-w-0 max-w-[88%]\">\n                  <div className=\"mb-1 flex items-center gap-2\">\n                    <span className=\"text-[15px] font-black tracking-[-0.01em] text-slate-900\">\n                      {row.reviewer.displayName ?? \"Anonymous\"}\n                    </span>\n                    <span className=\"text-[12px] font-medium text-slate-600\">{formatAge(row.createTimeIso)} ago</span>\n                  </div>\n                  <div className=\"rounded-[28px] rounded-tl-[14px] border border-white/68 bg-white/84 px-5 py-[18px] shadow-[0_12px_30px_rgba(15,23,42,0.1)] backdrop-blur-2xl\">\n                    <div className=\"mb-2.5\">\n                      <StarRow rating={row.starRating} />\n                    </div>\n                    <p className=\"text-[15px] font-medium leading-relaxed text-slate-800\">\n                      {row.comment || \"No written comment provided.\"}\n                    </p>\n                  </div>\n                </div>\n              </motion.div>\n            </AnimatePresence>\n\n            {isReplied && row.reply?.comment ? (\n              <motion.div\n                variants={bubbleVariants}\n                initial=\"hidden\"\n                animate=\"visible\"\n                transition={{ duration: 0.24, delay: 0.1, ease: [0.16, 1, 0.3, 1] }}\n                className=\"mb-7 flex items-start justify-end gap-3.5\"\n              >\n                <div className=\"min-w-0 max-w-[88%]\">\n                  <div className=\"mb-1 flex items-center justify-end gap-2 text-[11px] font-semibold text-slate-600\">\n                    Published reply\n                    <CheckCircle2 className=\"h-3.5 w-3.5 text-emerald-500\" strokeWidth={ICON_STROKE} />\n                  </div>\n                  <div className=\"rounded-[28px] rounded-tr-[14px] border border-white/68 bg-white/84 px-5 py-[18px] shadow-[0_12px_30px_rgba(15,23,42,0.1)] backdrop-blur-2xl\">\n                    <p className=\"text-[15px] font-medium leading-relaxed text-slate-800\">{row.reply.comment}</p>\n                  </div>\n                </div>\n                <AiAvatar />\n              </motion.div>\n            ) : null}\n\n            {!isReplied && (text || busy === \"generate\") ? (\n              <motion.div\n                variants={bubbleVariants}\n                initial=\"hidden\"\n                animate=\"visible\"\n                transition={{ duration: 0.24, delay: 0.1, ease: [0.16, 1, 0.3, 1] }}\n                className=\"mb-7 flex items-start justify-end gap-3.5\"\n              >\n                <div className=\"min-w-0 max-w-[88%]\">\n                  <div className=\"mb-1 flex items-center justify-end gap-2 text-[11px] font-semibold uppercase tracking-[0.11em] text-slate-600\">\n                    AI Draft\n                  </div>\n                  <div className=\"rounded-[28px] rounded-tr-[14px] border border-white/68 bg-white/84 px-5 py-[18px] shadow-[0_12px_30px_rgba(15,23,42,0.1)] backdrop-blur-2xl\">\n                    {busy === \"generate\" ? (\n                      <div className=\"flex min-h-[120px] items-center justify-center text-[#1a73e8]\">\n                        <div className=\"flex flex-col items-center gap-2\">\n                          <Loader2 className=\"h-6 w-6 animate-spin\" />\n                          <span className=\"text-[11px] font-semibold uppercase tracking-[0.12em]\">Generating response</span>\n                        </div>\n                      </div>\n                    ) : (\n                      <p className=\"whitespace-pre-wrap text-[15px] font-medium leading-relaxed text-slate-800\">{text}</p>\n                    )}\n                  </div>\n                </div>\n                <AiAvatar />\n              </motion.div>\n            ) : null}\n\n            {!isReplied && detail?.drafts && detail.drafts.length > 1 ? (\n              <DraftHistoryTimeline drafts={detail.drafts} currentDraftId={detail.currentDraft?.id ?? null} />\n            ) : null}\n\n            <AnimatePresence>\n              {inlineError ? (\n                <motion.div\n                  initial={{ opacity: 0, height: 0 }}\n                  animate={{ opacity: 1, height: \"auto\" }}\n                  exit={{ opacity: 0, height: 0 }}\n                  className=\"mb-4\"\n                >\n                  <InlineError error={inlineError} />\n                </motion.div>\n              ) : null}\n            </AnimatePresence>\n          </div>\n        </ScrollArea>\n\n        <AnimatePresence>\n          {isReplied ? (\n            <motion.div\n              initial={{ opacity: 0, y: 24 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: 24 }}\n              transition={{ duration: 0.3, ease: [0.16, 1, 0.3, 1] }}\n              className={INBOX_THEME_CLASSES.actionIslandWrap}\n            >\n              <div className={INBOX_THEME_CLASSES.actionIsland}>\n                <div className={INBOX_THEME_CLASSES.islandSuccess}>\n                   <CheckCircle2 className=\"h-5 w-5\" strokeWidth={ICON_STROKE} />\n                  <span className=\"text-sm font-black uppercase tracking-[0.12em]\">Published successfully</span>\n                </div>\n              </div>\n            </motion.div>\n          ) : (\n            <motion.div\n              initial={{ opacity: 0, y: 24 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: 24 }}\n              transition={{ duration: 0.32, ease: [0.16, 1, 0.3, 1] }}\n              className={INBOX_THEME_CLASSES.actionIslandWrap}\n            >\n              <div className={INBOX_THEME_CLASSES.actionIsland}>\n                <div className=\"relative mb-3.5\">\n                  {showGeneratingGlow ? (\n                    <div className=\"tahoe-intelligence-glow pointer-events-none absolute -inset-1 rounded-[40px] opacity-85 blur-[6px] motion-safe:animate-[spin_3.5s_linear_infinite]\" />\n                  ) : null}\n                  <div className=\"relative rounded-[40px] border border-white/25 bg-white/10 p-3\">\n                    <Textarea\n                      value={text}\n                      onChange={(event) => setText(event.target.value)}\n                      placeholder=\"Shape the final response before publishing...\"\n                      aria-label=\"Draft response\"\n                      disabled={busy === \"generate\"}\n                      rows={3}\n                      className=\"min-h-[112px] resize-none rounded-[32px] border-none bg-transparent px-2 py-1 text-[15px] font-medium leading-relaxed text-white shadow-none outline-none ring-0 placeholder:text-white/60 focus-visible:ring-0\"\n                    />\n                  </div>\n                </div>\n\n                <div className=\"flex flex-wrap items-center gap-2\">\n                  <DraftStatusChip status={currentDraftStatus} />\n\n                  <p className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n                    {saveState === \"saving\"\n                      ? \"Saving draft\"\n                      : saveState === \"saved\"\n                        ? \"Draft saved\"\n                        : \"Draft idle\"}\n                  </p>\n\n                  {saveState === \"saving\" ? (\n                    <span className=\"inline-flex items-center gap-1 text-[11px] font-semibold uppercase tracking-[0.1em] text-white/80\">\n                      <Loader2 className=\"h-3 w-3 animate-spin\" />\n                      Saving\n                    </span>\n                  ) : null}\n\n                  {saveState === \"saved\" ? (\n                    <span className=\"inline-flex items-center gap-1 text-[11px] font-semibold uppercase tracking-[0.1em] text-emerald-300\">\n                      <CheckCircle2 className=\"h-3 w-3\" strokeWidth={ICON_STROKE} />\n                      Saved\n                    </span>\n                  ) : null}\n\n                  <span className=\"ml-auto text-[11px] font-semibold uppercase tracking-[0.1em] text-white/72\">\n                    {wordCount} {wordCount === 1 ? \"word\" : \"words\"}\n                  </span>\n                </div>\n\n                <div className=\"mt-3 flex flex-wrap items-center gap-2\">\n                  <ActionButton\n                    tooltip=\"Generate AI draft\"\n                    ariaLabel=\"Generate AI draft\"\n                    onClick={() =>\n                      void runAction(\"generate\", async () => {\n                        await onGenerate(row.id)\n                      })\n                    }\n                    disabled={busy !== null}\n                    className=\"text-[#b5fffc]\"\n                  >\n                    {busy === \"generate\" ? <Loader2 className=\"h-4 w-4 animate-spin\" strokeWidth={ICON_STROKE} /> : <Sparkles className=\"h-4 w-4\" strokeWidth={ICON_STROKE} />}\n                  </ActionButton>\n\n                  <ActionButton\n                    tooltip={verifyTooltip}\n                    ariaLabel={verifyTooltip}\n                    onClick={() =>\n                      void runAction(\"verify\", async () => {\n                        await onVerify(row.id)\n                      })\n                    }\n                    disabled={verifyDisabled}\n                  >\n                    {busy === \"verify\" ? <RefreshCw className=\"h-4 w-4 animate-spin\" strokeWidth={ICON_STROKE} /> : <ShieldCheck className=\"h-4 w-4\" strokeWidth={ICON_STROKE} />}\n                  </ActionButton>\n\n                  <ActionButton\n                    tooltip=\"Save draft\"\n                    ariaLabel=\"Save draft\"\n                    onClick={() =>\n                      void runAction(\"save\", async () => {\n                        await onSave(row.id, text)\n                      })\n                    }\n                    disabled={busy !== null || !hasText || !isDirty}\n                  >\n                    {busy === \"save\" ? <RefreshCw className=\"h-4 w-4 animate-spin\" strokeWidth={ICON_STROKE} /> : <Save className=\"h-4 w-4\" strokeWidth={ICON_STROKE} />}\n                  </ActionButton>\n\n                  <ActionButton tooltip=\"Copy draft\" ariaLabel=\"Copy draft\" onClick={() => void copyDraft()} disabled={!hasText}>\n                    <Copy className=\"h-4 w-4\" strokeWidth={ICON_STROKE} />\n                  </ActionButton>\n\n                  <span className=\"hidden text-[11px] font-semibold uppercase tracking-[0.1em] text-white/70 md:inline\">\n                    ⌘↵ publish\n                  </span>\n\n                  <Button\n                    type=\"button\"\n                    onClick={() =>\n                      void runAction(\"publish\", async () => {\n                        await onPublish(row.id, text, row)\n                      })\n                    }\n                    disabled={busy !== null || !hasText}\n                    className={cn(INBOX_THEME_CLASSES.islandPrimary, \"ml-auto\")}\n                  >\n                    {busy === \"publish\" ? (\n                      <Loader2 className=\"mr-1.5 h-4 w-4 animate-spin\" strokeWidth={ICON_STROKE} />\n                    ) : (\n                      <Send className=\"mr-1.5 h-4 w-4\" strokeWidth={ICON_STROKE} />\n                    )}\n                    Publish\n                  </Button>\n                </div>\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </section>\n    </TooltipProvider>\n  )\n}\n"
    },
    {
      "path": "app/(app)/inbox/components/InboxFilterBar.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/components/InboxFilterBar.tsx",
      "bytes": 9326,
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { AnimatePresence, motion } from \"framer-motion\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport { Filter, RefreshCw, Send, X } from \"lucide-react\"\nimport { INBOX_THEME_CLASSES } from \"@/lib/design-system/inbox-theme\"\nimport { cn } from \"@/lib/utils\"\n\nimport type { ReviewFilter } from \"@/lib/hooks\"\nimport type { LocationOption } from \"../types\"\n\ntype InboxFilterBarProps = {\n  filter: ReviewFilter\n  onFilterChange: (value: ReviewFilter) => void\n  mentionFilter: string\n  onMentionFilterChange: (value: string) => void\n  mentionKeywords: string[]\n  locationFilter: string\n  onLocationFilterChange: (value: string) => void\n  locations: LocationOption[]\n  ratingFilter: string\n  onRatingFilterChange: (value: string) => void\n  activeFiltersCount: number\n  onReset: () => void\n  onBulkApprove: () => void\n  bulkApproveCount: number\n  bulkApproveLoading: boolean\n  bulkApproveEnabled: boolean\n}\n\nconst ICON_STROKE = 2.6\nconst FILTER_PANEL_ID = \"inbox-filter-panel\"\n\nconst FILTER_OPTIONS: Array<{ value: ReviewFilter; label: string }> = [\n  { value: \"unanswered\", label: \"Pending\" },\n  { value: \"urgent\", label: \"Urgent\" },\n  { value: \"five_star\", label: \"5 Star\" },\n  { value: \"mentions\", label: \"Mentions\" },\n  { value: \"all\", label: \"All\" },\n]\n\nconst RATING_OPTIONS = [\n  { value: \"all\", label: \"Any rating\" },\n  { value: \"5\", label: \"5★\" },\n  { value: \"4\", label: \"4★\" },\n  { value: \"3\", label: \"3★\" },\n  { value: \"2\", label: \"2★\" },\n  { value: \"1\", label: \"1★\" },\n] as const\n\nexport function InboxFilterBar({\n  filter,\n  onFilterChange,\n  mentionFilter,\n  onMentionFilterChange,\n  mentionKeywords,\n  locationFilter,\n  onLocationFilterChange,\n  locations,\n  ratingFilter,\n  onRatingFilterChange,\n  activeFiltersCount,\n  onReset,\n  onBulkApprove,\n  bulkApproveCount,\n  bulkApproveLoading,\n  bulkApproveEnabled,\n}: InboxFilterBarProps) {\n  const [expanded, setExpanded] = React.useState(false)\n  const activeFilterSummary = React.useMemo(() => {\n    const parts: string[] = []\n    if (filter !== \"unanswered\") {\n      const currentFilter = FILTER_OPTIONS.find((option) => option.value === filter)\n      if (currentFilter) {\n        parts.push(currentFilter.label)\n      }\n    }\n\n    if (filter === \"mentions\") {\n      if (mentionFilter.trim()) {\n        parts.push(`@${mentionFilter.trim()}`)\n      }\n    } else if (locationFilter !== \"all\") {\n      const locationName = locations.find((location) => location.id === locationFilter)?.displayName\n      if (locationName) {\n        parts.push(locationName)\n      }\n    }\n\n    if (ratingFilter !== \"all\") {\n      parts.push(`${ratingFilter}★`)\n    }\n\n    return parts\n  }, [filter, locationFilter, locations, mentionFilter, ratingFilter])\n\n  return (\n    <section className={INBOX_THEME_CLASSES.filterSection}>\n      <div className=\"flex items-center justify-between gap-2.5\">\n        <div className=\"flex items-center gap-2.5\">\n          <button\n            type=\"button\"\n            onClick={() => setExpanded((prev) => !prev)}\n            aria-expanded={expanded}\n            aria-controls={FILTER_PANEL_ID}\n            className={cn(\n              INBOX_THEME_CLASSES.filterToggle,\n              expanded\n                ? INBOX_THEME_CLASSES.filterToggleActive\n                : INBOX_THEME_CLASSES.filterToggleIdle,\n            )}\n          >\n            <Filter className=\"h-3.5 w-3.5\" strokeWidth={ICON_STROKE} />\n            Filters\n          </button>\n\n          {!expanded && activeFiltersCount > 0 ? (\n            <div className=\"flex min-w-0 items-center gap-2\">\n              <span className={INBOX_THEME_CLASSES.filterActivePill}>\n                {activeFiltersCount} active\n                <button\n                  type=\"button\"\n                  onClick={onReset}\n                  className=\"rounded-full p-0.5 text-[#1a73e8] transition-colors hover:text-[#1765cb]\"\n                  aria-label=\"Reset filters\"\n                >\n                  <X className=\"h-3 w-3\" strokeWidth={ICON_STROKE} />\n                </button>\n              </span>\n              {activeFilterSummary.length > 0 ? (\n                <span\n                  className=\"min-w-0 truncate text-[11px] font-semibold uppercase tracking-[0.08em] text-slate-600\"\n                  aria-label={`Active filters: ${activeFilterSummary.join(\", \")}`}\n                >\n                  {activeFilterSummary.join(\" • \")}\n                </span>\n              ) : null}\n            </div>\n          ) : null}\n        </div>\n\n        <Button\n          type=\"button\"\n          size=\"sm\"\n          className={\n            bulkApproveCount > 0 && bulkApproveEnabled && !bulkApproveLoading\n              ? INBOX_THEME_CLASSES.bulkApproveActive\n              : INBOX_THEME_CLASSES.bulkApproveIdle\n          }\n          onClick={onBulkApprove}\n          disabled={bulkApproveLoading || !bulkApproveEnabled || bulkApproveCount === 0}\n          aria-label={`Bulk approve ${bulkApproveCount} reviews`}\n        >\n          {bulkApproveLoading ? (\n            <RefreshCw className=\"mr-1.5 h-3 w-3 animate-spin\" strokeWidth={ICON_STROKE} />\n          ) : (\n            <Send className=\"mr-1.5 h-3 w-3\" strokeWidth={ICON_STROKE} />\n          )}\n          Approve {bulkApproveCount}\n        </Button>\n      </div>\n\n      <AnimatePresence initial={false}>\n        {expanded ? (\n          <motion.div\n            id={FILTER_PANEL_ID}\n            role=\"region\"\n            aria-label=\"Inbox filters\"\n            initial={{ height: 0, opacity: 0 }}\n            animate={{ height: \"auto\", opacity: 1 }}\n            exit={{ height: 0, opacity: 0 }}\n            transition={{ duration: 0.24, ease: [0.16, 1, 0.3, 1] }}\n            className=\"overflow-hidden\"\n          >\n            <div className=\"mb-2.5 h-[2px] rounded-full bg-[linear-gradient(90deg,#1a73e8_0%,#ea4335_35%,#fbbc04_68%,#34a853_100%)] opacity-80\" />\n            <div className=\"mt-3 flex items-center gap-2.5 overflow-x-auto pb-1.5\">\n              <Select value={filter} onValueChange={(value) => onFilterChange(value as ReviewFilter)}>\n                <SelectTrigger className={cn(INBOX_THEME_CLASSES.filterSelectTrigger, \"min-w-[110px]\")}>\n                  <SelectValue placeholder=\"Queue\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {FILTER_OPTIONS.map((option) => (\n                    <SelectItem\n                      key={option.value}\n                      value={option.value}\n                      disabled={option.value === \"mentions\" && mentionKeywords.length === 0}\n                    >\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n\n              {filter === \"mentions\" ? (\n                <Select value={mentionFilter || \"\"} onValueChange={onMentionFilterChange}>\n                  <SelectTrigger className={cn(INBOX_THEME_CLASSES.filterSelectTrigger, \"min-w-[115px]\")}>\n                    <SelectValue placeholder=\"Keyword\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    {mentionKeywords.map((keyword) => (\n                      <SelectItem key={keyword} value={keyword}>\n                        {keyword}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              ) : (\n                <Select value={locationFilter} onValueChange={onLocationFilterChange}>\n                  <SelectTrigger className={cn(INBOX_THEME_CLASSES.filterSelectTrigger, \"min-w-[125px]\")}>\n                    <SelectValue placeholder=\"Location\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"all\">All locations</SelectItem>\n                    {locations.map((location) => (\n                      <SelectItem key={location.id} value={location.id}>\n                        {location.displayName}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n\n              <Select value={ratingFilter} onValueChange={onRatingFilterChange}>\n                <SelectTrigger className={cn(INBOX_THEME_CLASSES.filterSelectTrigger, \"min-w-[98px]\")}>\n                  <SelectValue placeholder=\"Rating\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {RATING_OPTIONS.map((option) => (\n                    <SelectItem key={option.value} value={option.value}>\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n\n              {activeFiltersCount > 0 ? (\n                <button\n                  type=\"button\"\n                  onClick={onReset}\n                  className={INBOX_THEME_CLASSES.filterResetButton}\n                >\n                  Reset\n                </button>\n              ) : null}\n            </div>\n          </motion.div>\n        ) : null}\n      </AnimatePresence>\n\n      <p className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n        {activeFiltersCount} active filters.\n      </p>\n    </section>\n  )\n}\n"
    },
    {
      "path": "app/(app)/inbox/components/InboxHeader.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/components/InboxHeader.tsx",
      "bytes": 5944,
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { motion } from \"framer-motion\"\n\nimport { NotificationCenter } from \"@/components/NotificationCenter\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { RefreshCw, Search, Sparkles } from \"lucide-react\"\nimport { INBOX_THEME_CLASSES, inboxGoogleDotClass, inboxSegmentedClass } from \"@/lib/design-system/inbox-theme\"\nimport { cn } from \"@/lib/utils\"\n\nconst ICON_STROKE = 2.6\nconst GOOGLE_DOT_COUNT = 4\n\nexport type InboxTab = \"pending\" | \"replied\" | \"all\"\n\ntype InboxHeaderProps = {\n  pendingCount: number\n  tab: InboxTab\n  onTabChange: (value: InboxTab) => void\n  search: string\n  onSearchChange: (value: string) => void\n  refreshing: boolean\n  onRefresh: () => void\n}\n\nconst TAB_OPTIONS: Array<{ value: InboxTab; label: string }> = [\n  { value: \"pending\", label: \"Pending\" },\n  { value: \"replied\", label: \"Replied\" },\n  { value: \"all\", label: \"All\" },\n]\n\nconst TABLIST_ID = \"inbox-tablist\"\n\nexport function InboxHeader({\n  pendingCount,\n  tab,\n  onTabChange,\n  search,\n  onSearchChange,\n  refreshing,\n  onRefresh,\n}: InboxHeaderProps) {\n  const tabRefs = React.useRef<Array<HTMLButtonElement | null>>([])\n\n  const handleTabKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLButtonElement>, index: number) => {\n      const lastIndex = TAB_OPTIONS.length - 1\n      let nextIndex: number | null = null\n\n      if (event.key === \"ArrowRight\") nextIndex = index === lastIndex ? 0 : index + 1\n      if (event.key === \"ArrowLeft\") nextIndex = index === 0 ? lastIndex : index - 1\n      if (event.key === \"Home\") nextIndex = 0\n      if (event.key === \"End\") nextIndex = lastIndex\n\n      if (nextIndex == null) return\n      event.preventDefault()\n      onTabChange(TAB_OPTIONS[nextIndex].value)\n      requestAnimationFrame(() => {\n        tabRefs.current[nextIndex]?.focus()\n      })\n    },\n    [onTabChange],\n  )\n\n  return (\n    <motion.header\n      initial={{ opacity: 0, y: -8 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.32, ease: [0.16, 1, 0.3, 1] }}\n      className={INBOX_THEME_CLASSES.headerSection}\n    >\n      <div className={INBOX_THEME_CLASSES.headerAccentRail} />\n\n      <div className=\"mb-3.5 flex items-center justify-between gap-2.5\">\n        <div className=\"min-w-0\">\n          <div className=\"mb-0.5 flex items-center gap-2\">\n            <p className=\"text-[11px] font-semibold uppercase tracking-[0.14em] text-slate-600\">Tahoe Inbox • Google-tuned</p>\n            <span className=\"inline-flex items-center gap-1\" aria-hidden>\n              {Array.from({ length: GOOGLE_DOT_COUNT }, (_, index) => (\n                <span\n                  key={`header-dot-${String(index)}`}\n                  className={cn(\"h-1.5 w-1.5 rounded-full shadow-[0_0_0_1px_rgba(255,255,255,0.65)]\", inboxGoogleDotClass(index))}\n                />\n              ))}\n            </span>\n          </div>\n          <div className=\"flex items-center gap-2.5\">\n            <h2 className=\"truncate text-[2.05rem] font-black leading-none tracking-[-0.04em] text-slate-900\">Reviews</h2>\n            {pendingCount > 0 ? (\n              <span className={INBOX_THEME_CLASSES.headerPendingPill} aria-label={`${pendingCount} pending reviews`}>\n                {pendingCount}\n              </span>\n            ) : null}\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <NotificationCenter className={cn(INBOX_THEME_CLASSES.iconButton, \"backdrop-blur-xl\")} />\n          <Button\n            type=\"button\"\n            variant=\"ghost\"\n            size=\"icon\"\n            className={INBOX_THEME_CLASSES.iconButton}\n            onClick={onRefresh}\n            aria-label=\"Refresh inbox\"\n          >\n            <RefreshCw className={cn(\"h-4 w-4\", refreshing && \"animate-spin\")} strokeWidth={ICON_STROKE} />\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"relative mb-3.5\">\n        <Search className=\"pointer-events-none absolute left-3.5 top-1/2 h-4 w-4 -translate-y-1/2 text-slate-500\" strokeWidth={ICON_STROKE} />\n        <Input\n          id=\"inbox-search-input\"\n          type=\"search\"\n          placeholder=\"Search reviewer, content, or location\"\n          value={search}\n          onChange={(event) => onSearchChange(event.target.value)}\n          className={INBOX_THEME_CLASSES.searchInput}\n          aria-label=\"Search inbox reviews\"\n        />\n      </div>\n\n      <div className={INBOX_THEME_CLASSES.segmented} role=\"tablist\" aria-label=\"Review status tabs\" id={TABLIST_ID}>\n        <div className=\"grid grid-cols-3 gap-1\" role=\"presentation\">\n          {TAB_OPTIONS.map((option, index) => (\n            <button\n              key={option.value}\n              id={`inbox-tab-${option.value}`}\n              type=\"button\"\n              role=\"tab\"\n              ref={(element) => {\n                tabRefs.current[index] = element\n              }}\n              tabIndex={option.value === tab ? 0 : -1}\n              aria-selected={option.value === tab}\n              aria-controls=\"inbox-review-list-panel\"\n              data-tab-index={index}\n              onClick={() => onTabChange(option.value)}\n              onKeyDown={(event) => handleTabKeyDown(event, index)}\n              className={cn(inboxSegmentedClass(option.value === tab), \"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#1a73e8]/38\")}\n            >\n              {option.label}\n            </button>\n          ))}\n        </div>\n      </div>\n\n      <p className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n        {pendingCount} pending reviews.\n      </p>\n\n      <div className=\"mt-3 flex items-center gap-1.5 text-[11px] font-semibold uppercase tracking-[0.14em] text-slate-600\">\n        <Sparkles className=\"h-3.5 w-3.5 text-[#1a73e8]\" strokeWidth={ICON_STROKE} />\n        AI responses keep brand tone with Google-style clarity\n      </div>\n    </motion.header>\n  )\n}\n"
    },
    {
      "path": "app/(app)/inbox/components/InboxReviewList.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/components/InboxReviewList.tsx",
      "bytes": 4870,
      "content": "\"use client\"\n\nimport * as React from \"react\"\n\nimport { EmptyState } from \"@/components/ErrorStates\"\nimport { ReviewCard } from \"@/components/ReviewCard\"\nimport { Inbox, RefreshCw } from \"lucide-react\"\nimport { Button } from \"@/components/ui/button\"\nimport { SkeletonList } from \"@/components/ui/progress\"\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\nimport { INBOX_THEME_CLASSES } from \"@/lib/design-system/inbox-theme\"\nimport { useSmoothLoading } from \"@/lib/hooks/useSmoothLoading\"\n\nimport type { ReviewRow } from \"@/lib/hooks\"\n\ntype InboxReviewListProps = {\n  activeTab: \"pending\" | \"replied\" | \"all\"\n  rows: ReviewRow[]\n  activeReviewId: string | null\n  loading: boolean\n  error: string | null\n  hasMore: boolean\n  loadingMore: boolean\n  showQuickApprove: boolean\n  quickApproveLoadingId: string | null\n  onOpenReview: (reviewId: string) => void\n  onQuickApprove: (reviewId: string) => void\n  onGenerateDraft: (reviewId: string) => Promise<void>\n  onSaveDraft: (reviewId: string, text: string, options?: { silent?: boolean }) => Promise<void>\n  onVerifyDraft: (reviewId: string) => Promise<void>\n  onPublishReply: (reviewId: string, text: string, row: ReviewRow) => Promise<void>\n  onLoadMore: () => void\n  onRetry: () => void\n}\n\nconst ICON_STROKE = 2.6\nconst NOOP_CHECKED_CHANGE: (reviewId: string, checked: boolean) => void = () => {}\n\nexport const InboxReviewList = React.memo(function InboxReviewList({\n  activeTab,\n  rows,\n  activeReviewId,\n  loading,\n  error,\n  hasMore,\n  loadingMore,\n  showQuickApprove,\n  quickApproveLoadingId,\n  onOpenReview,\n  onQuickApprove,\n  onGenerateDraft,\n  onSaveDraft,\n  onVerifyDraft,\n  onPublishReply,\n  onLoadMore,\n  onRetry,\n}: InboxReviewListProps) {\n  const showLoading = useSmoothLoading(loading && rows.length === 0, { delayMs: 120, minDurationMs: 420 })\n  const hasRows = !showLoading && !error && rows.length > 0\n\n  return (\n    <section\n      id=\"inbox-review-list-panel\"\n      role=\"tabpanel\"\n      aria-labelledby={`inbox-tab-${activeTab}`}\n      aria-busy={showLoading || loadingMore}\n      className={INBOX_THEME_CLASSES.feedListSection}\n    >\n      <ScrollArea className=\"h-full\">\n        <div className={INBOX_THEME_CLASSES.feedListInner} role=\"list\" aria-label=\"Reviews list\">\n          <p className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n            {showLoading ? \"Loading reviews.\" : `${rows.length} reviews loaded.`}\n          </p>\n\n          {showLoading ? <SkeletonList count={4} /> : null}\n\n          {!showLoading && error ? (\n            <EmptyState\n              title=\"Unable to load reviews\"\n              description={error}\n              action={{ label: \"Retry\", onClick: onRetry }}\n            />\n          ) : null}\n\n          {!showLoading && !error && rows.length === 0 ? (\n            <EmptyState\n              icon={Inbox}\n              title=\"All caught up\"\n              description=\"No conversations match the current queue and filters.\"\n              action={{ label: \"Refresh\", onClick: onRetry }}\n            />\n          ) : null}\n\n          {hasRows\n            ? rows.map((row) => (\n                <div key={row.id} role=\"listitem\" className=\"[contain-intrinsic-size:180px] [content-visibility:auto]\">\n                  <ReviewCard\n                    reviewId={row.id}\n                    row={row}\n                    showCheckbox={false}\n                    checked={false}\n                    onCheckedChange={NOOP_CHECKED_CHANGE}\n                    onOpen={onOpenReview}\n                    selected={row.id === activeReviewId}\n                    showQuickApprove={showQuickApprove}\n                    onQuickApprove={onQuickApprove}\n                    quickApproveLoading={quickApproveLoadingId === row.id}\n                    onGenerateDraft={onGenerateDraft}\n                    onSaveDraft={onSaveDraft}\n                    onVerifyDraft={onVerifyDraft}\n                    onPublishReply={onPublishReply}\n                  />\n                </div>\n              ))\n            : null}\n\n          {!showLoading && !error && hasMore ? (\n            <div className=\"pt-2\">\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                className={INBOX_THEME_CLASSES.listLoadMoreButton}\n                onClick={onLoadMore}\n                disabled={loadingMore}\n                aria-label={loadingMore ? \"Loading more reviews\" : \"Load more reviews\"}\n              >\n                {loadingMore ? (\n                  <>\n                    <RefreshCw className=\"mr-1.5 h-3.5 w-3.5 animate-spin\" strokeWidth={ICON_STROKE} />\n                    Loading\n                  </>\n                ) : (\n                  \"Load more\"\n                )}\n              </Button>\n            </div>\n          ) : null}\n        </div>\n      </ScrollArea>\n    </section>\n  )\n})\n\nInboxReviewList.displayName = \"InboxReviewList\"\n"
    },
    {
      "path": "app/(app)/inbox/hooks/useReviewMutations.ts",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/hooks/useReviewMutations.ts",
      "bytes": 13033,
      "content": "import * as React from \"react\"\nimport { toast } from \"sonner\"\n\nimport { applyDetailSnapshot, getVerifierBlockedMessage, mapDetailToRow } from \"../model\"\nimport { apiCall, fetchReviewDetail, waitForJobCompletion, waitForReviewState } from \"../network\"\n\nimport type { ReviewDetail, ReviewRow } from \"@/lib/hooks\"\nimport type { ReviewMutationResponse } from \"../types\"\n\nconst QUICK_JOB_WAIT_MS = 1800\nconst BACKGROUND_JOB_WAIT_MS = 25_000\n\ntype UseReviewMutationsInput = {\n  rows: ReviewRow[]\n  updateRow: (id: string, updater: (row: ReviewRow) => ReviewRow) => void\n  refresh: () => Promise<void> | void\n  onQueuedJob?: (event: {\n    jobId: string\n    reviewId: string\n    operation: \"generate\" | \"verify\" | \"publish\"\n  }) => void\n}\n\nexport function useReviewMutations({ rows, updateRow, refresh, onQueuedJob }: UseReviewMutationsInput) {\n  const backgroundJobsRef = React.useRef<Set<string>>(new Set())\n\n  const getJobId = React.useCallback((result: ReviewMutationResponse) => {\n    return result.jobId ?? result.verifyJobId ?? result.job?.id ?? null\n  }, [])\n\n  const syncRowFromServer = React.useCallback(async (reviewId: string) => {\n    const detail = await fetchReviewDetail(reviewId)\n    if (detail) {\n      updateRow(reviewId, (row) => mapDetailToRow(row, detail))\n    }\n    return detail\n  }, [updateRow])\n\n  const syncRowFromSnapshotOrServer = React.useCallback(async (reviewId: string, detail: ReviewDetail | null) => {\n    if (detail) {\n      updateRow(reviewId, (row) => mapDetailToRow(row, detail))\n      return detail\n    }\n    return syncRowFromServer(reviewId)\n  }, [syncRowFromServer, updateRow])\n\n  const resolveTerminalFailureMessage = React.useCallback((params: {\n    status: \"FAILED\" | \"CANCELLED\"\n    fallbackMessage: string\n    lastError: string | null\n  }) => {\n    const { status, fallbackMessage, lastError } = params\n    if (lastError === \"DRAFT_STALE\" || lastError?.includes('\"code\":\"DRAFT_STALE\"')) {\n      return \"Draft changed while posting. Publish again to send the latest draft.\"\n    }\n    if (lastError) return lastError\n    if (status === \"CANCELLED\") return \"This job was cancelled before completion.\"\n    return fallbackMessage\n  }, [])\n\n  const settleQueuedJob = React.useCallback(async (params: {\n    jobId: string\n    reviewId: string\n    operation: \"generate\" | \"verify\" | \"publish\"\n    queuedMessage: string\n    successMessage: string\n    failureMessage: string\n    onCompleted: (reviewSnapshot: ReviewDetail | null) => Promise<void>\n  }) => {\n    const { jobId, reviewId, operation, queuedMessage, successMessage, failureMessage, onCompleted } = params\n\n    const quickResult = await waitForJobCompletion(jobId, QUICK_JOB_WAIT_MS)\n    if (quickResult?.job.status === \"FAILED\" || quickResult?.job.status === \"CANCELLED\") {\n      throw new Error(\n        resolveTerminalFailureMessage({\n          status: quickResult.job.status,\n          fallbackMessage: failureMessage,\n          lastError: quickResult.job.lastError,\n        }),\n      )\n    }\n\n    if (quickResult?.job.status === \"COMPLETED\") {\n      await onCompleted(quickResult.review ?? null)\n      toast.success(successMessage)\n      return\n    }\n\n    toast.success(queuedMessage)\n    onQueuedJob?.({ jobId, reviewId, operation })\n    if (backgroundJobsRef.current.has(jobId)) return\n    backgroundJobsRef.current.add(jobId)\n\n    void (async () => {\n      try {\n        const final = await waitForJobCompletion(jobId, BACKGROUND_JOB_WAIT_MS)\n        if (!final) return\n\n        if (final.job.status === \"FAILED\" || final.job.status === \"CANCELLED\") {\n          toast.error(\n            resolveTerminalFailureMessage({\n              status: final.job.status,\n              fallbackMessage: failureMessage,\n              lastError: final.job.lastError,\n            }),\n          )\n          return\n        }\n\n        await onCompleted(final.review ?? null)\n        toast.success(successMessage)\n      } catch (error) {\n        toast.error(error instanceof Error ? error.message : failureMessage)\n      } finally {\n        backgroundJobsRef.current.delete(jobId)\n      }\n    })()\n  }, [onQueuedJob, resolveTerminalFailureMessage])\n\n  const generateDraft = React.useCallback(async (reviewId: string) => {\n    const previousDraftId = rows.find((row) => row.id === reviewId)?.currentDraft?.id ?? null\n    const result = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/drafts/generate`, \"POST\")\n\n    if (applyDetailSnapshot(reviewId, result.review, updateRow)) {\n      toast.success(\"Draft regenerated\")\n      return\n    }\n\n    const jobId = getJobId(result)\n    if (jobId) {\n      await settleQueuedJob({\n        jobId,\n        reviewId,\n        operation: \"generate\",\n        queuedMessage: \"Draft generation queued\",\n        successMessage: \"Draft regenerated\",\n        failureMessage: \"Draft generation failed.\",\n        onCompleted: async (reviewSnapshot) => {\n          await syncRowFromSnapshotOrServer(reviewId, reviewSnapshot)\n        },\n      })\n      return\n    }\n\n    const changed = await waitForReviewState(\n      reviewId,\n      (detail) => {\n        const currentDraftId = detail.currentDraft?.id ?? null\n        return previousDraftId == null ? currentDraftId != null : currentDraftId !== previousDraftId\n      },\n      5000,\n    )\n\n    if (changed) {\n      updateRow(reviewId, (row) => mapDetailToRow(row, changed))\n      toast.success(\"Draft regenerated\")\n    } else {\n      toast.success(\"Draft generation queued\")\n    }\n  }, [getJobId, rows, settleQueuedJob, syncRowFromSnapshotOrServer, updateRow])\n\n  const saveDraft = React.useCallback(async (reviewId: string, text: string, options?: { silent?: boolean }) => {\n    const silent = options?.silent ?? false\n    const trimmed = text.trim()\n    if (!trimmed) throw new Error(\"Draft is empty.\")\n\n    const result = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/drafts/edit`, \"POST\", { text: trimmed })\n    if (applyDetailSnapshot(reviewId, result.review, updateRow)) {\n      if (!silent) toast.success(\"Draft saved\")\n      return\n    }\n\n    const claimed = Number(result?.worker?.claimed ?? 0)\n    const changed = await waitForReviewState(\n      reviewId,\n      (detail) => (detail.currentDraft?.text.trim() ?? \"\") === trimmed,\n      claimed > 0 ? 5000 : 6500,\n    )\n\n    if (changed) {\n      updateRow(reviewId, (row) => mapDetailToRow(row, changed))\n      if (!silent) toast.success(\"Draft saved\")\n    }\n  }, [updateRow])\n\n  const verifyDraft = React.useCallback(async (reviewId: string) => {\n    const currentRow = rows.find((row) => row.id === reviewId)\n    if (currentRow?.currentDraft?.status === \"READY\") {\n      toast.success(\"Draft already verified\")\n      return\n    }\n\n    const result = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/drafts/verify`, \"POST\")\n    if (applyDetailSnapshot(reviewId, result.review, updateRow)) {\n      if (result.review?.currentDraft?.status === \"BLOCKED_BY_VERIFIER\") {\n        throw new Error(getVerifierBlockedMessage(result.review))\n      }\n      toast.success(\"Draft verified\")\n      return\n    }\n\n    const jobId = getJobId(result)\n    if (jobId) {\n      await settleQueuedJob({\n        jobId,\n        reviewId,\n        operation: \"verify\",\n        queuedMessage: \"Draft verification queued\",\n        successMessage: \"Draft verified\",\n        failureMessage: \"Draft verification failed.\",\n        onCompleted: async (reviewSnapshot) => {\n          const detail = await syncRowFromSnapshotOrServer(reviewId, reviewSnapshot)\n          if (detail?.currentDraft?.status === \"BLOCKED_BY_VERIFIER\") {\n            throw new Error(getVerifierBlockedMessage(detail))\n          }\n        },\n      })\n      return\n    }\n\n    const claimed = Number(result?.worker?.claimed ?? 0)\n    const verified = await waitForReviewState(\n      reviewId,\n      (detail) => {\n        const status = detail.currentDraft?.status\n        return status === \"READY\" || status === \"BLOCKED_BY_VERIFIER\"\n      },\n      claimed > 0 ? 5000 : 7000,\n    )\n\n    if (!verified) throw new Error(\"Verification is still processing. Please retry.\")\n\n    updateRow(reviewId, (row) => mapDetailToRow(row, verified))\n    if (verified.currentDraft?.status === \"BLOCKED_BY_VERIFIER\") {\n      throw new Error(getVerifierBlockedMessage(verified))\n    }\n    toast.success(\"Draft verified\")\n  }, [getJobId, rows, settleQueuedJob, syncRowFromSnapshotOrServer, updateRow])\n\n  const publishReply = React.useCallback(async (reviewId: string, text: string, row: ReviewRow) => {\n    if (!text.trim()) throw new Error(\"Draft is empty.\")\n\n    const current = row.currentDraft?.text.trim() ?? \"\"\n    const incoming = text.trim()\n    let verified: ReviewDetail | null = null\n    const canSkipVerify = current === incoming && row.currentDraft?.status === \"READY\"\n\n    if (current !== incoming) {\n      const editResult = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/drafts/edit`, \"POST\", { text: incoming })\n      if (applyDetailSnapshot(reviewId, editResult.review, updateRow)) {\n        verified = editResult.review ?? null\n      }\n\n      const editClaimed = Number(editResult?.worker?.claimed ?? 0)\n      if (!verified) {\n        const afterEdit = await waitForReviewState(\n          reviewId,\n          (detail) => {\n            const currentText = detail.currentDraft?.text.trim() ?? \"\"\n            const status = detail.currentDraft?.status\n            return currentText === incoming && (status === \"READY\" || status === \"BLOCKED_BY_VERIFIER\")\n          },\n          editClaimed > 0 ? 5000 : 6500,\n        )\n        if (afterEdit) {\n          updateRow(reviewId, (nextRow) => mapDetailToRow(nextRow, afterEdit))\n          verified = afterEdit\n        }\n      }\n    }\n\n    if (!verified && !canSkipVerify) {\n      const verifyResult = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/drafts/verify`, \"POST\")\n      if (applyDetailSnapshot(reviewId, verifyResult.review, updateRow)) {\n        verified = verifyResult.review ?? null\n      }\n\n      const verifyJobId = getJobId(verifyResult)\n      if (!verified && verifyJobId) {\n        await settleQueuedJob({\n          jobId: verifyJobId,\n          reviewId,\n          operation: \"verify\",\n          queuedMessage: \"Draft verification queued\",\n          successMessage: \"Draft verified\",\n          failureMessage: \"Draft verification failed.\",\n          onCompleted: async (reviewSnapshot) => {\n            verified = await syncRowFromSnapshotOrServer(reviewId, reviewSnapshot)\n            if (verified?.currentDraft?.status === \"BLOCKED_BY_VERIFIER\") {\n              throw new Error(getVerifierBlockedMessage(verified))\n            }\n          },\n        })\n      }\n\n      const verifyClaimed = Number(verifyResult?.worker?.claimed ?? 0)\n      if (!verified) {\n        verified = await waitForReviewState(\n          reviewId,\n          (detail) => {\n            const status = detail.currentDraft?.status\n            return status === \"READY\" || status === \"BLOCKED_BY_VERIFIER\"\n          },\n          verifyClaimed > 0 ? 5000 : 7000,\n        )\n      }\n    }\n\n    const verifiedDetail = verified ?? (canSkipVerify ? await syncRowFromServer(reviewId) : null)\n    if (!verifiedDetail) throw new Error(\"Verification is still processing. Please try publishing again in a few seconds.\")\n\n    updateRow(reviewId, (nextRow) => mapDetailToRow(nextRow, verifiedDetail))\n    if (verifiedDetail.currentDraft?.status !== \"READY\") {\n      throw new Error(getVerifierBlockedMessage(verifiedDetail))\n    }\n\n    const postResult = await apiCall<ReviewMutationResponse>(`/api/reviews/${reviewId}/reply/post`, \"POST\")\n    if (applyDetailSnapshot(reviewId, postResult.review, updateRow) && postResult.review?.reply.comment) {\n      toast.success(\"Reply published\")\n      void refresh()\n      return\n    }\n\n    const postJobId = getJobId(postResult)\n    if (postJobId) {\n      await settleQueuedJob({\n        jobId: postJobId,\n        reviewId,\n        operation: \"publish\",\n        queuedMessage: \"Reply posting queued\",\n        successMessage: \"Reply published\",\n        failureMessage: \"Reply posting failed.\",\n        onCompleted: async (reviewSnapshot) => {\n          const posted = await syncRowFromSnapshotOrServer(reviewId, reviewSnapshot)\n          if (!posted?.reply.comment) {\n            await Promise.resolve(refresh())\n            return\n          }\n          await Promise.resolve(refresh())\n        },\n      })\n      return\n    }\n\n    const postClaimed = Number(postResult?.worker?.claimed ?? 0)\n    const posted = await waitForReviewState(\n      reviewId,\n      (detail) => detail.reply.comment != null,\n      postClaimed > 0 ? 4500 : 7000,\n    )\n\n    if (posted) {\n      updateRow(reviewId, (nextRow) => mapDetailToRow(nextRow, posted))\n      toast.success(\"Reply published\")\n    } else {\n      toast.success(\"Reply posting queued\")\n    }\n\n    void refresh()\n  }, [getJobId, refresh, settleQueuedJob, syncRowFromServer, syncRowFromSnapshotOrServer, updateRow])\n\n  return {\n    generateDraft,\n    saveDraft,\n    verifyDraft,\n    publishReply,\n  }\n}\n"
    },
    {
      "path": "app/(app)/inbox/InboxClient.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/InboxClient.tsx",
      "bytes": 14109,
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useSearchParams } from \"next/navigation\"\nimport { toast } from \"sonner\"\n\nimport { ErrorBoundary, ErrorState } from \"@/components/ErrorStates\"\nimport { NotificationProvider, useNotifications } from \"@/components/NotificationCenter\"\nimport { INBOX_THEME_CLASSES } from \"@/lib/design-system/inbox-theme\"\nimport { usePaginatedReviews, type ReviewFilter, type ReviewRow } from \"@/lib/hooks\"\nimport { cn } from \"@/lib/utils\"\n\nimport { InboxFilterBar } from \"./components/InboxFilterBar\"\nimport { InboxHeader, type InboxTab } from \"./components/InboxHeader\"\nimport { InboxReviewList } from \"./components/InboxReviewList\"\nimport { useReviewMutations } from \"./hooks/useReviewMutations\"\nimport { canBulkApprove, parseFilter, resolveRemoteFilter } from \"./model\"\nimport { apiCall } from \"./network\"\n\nimport type { InboxBootstrap } from \"./types\"\n\ntype BulkApproveResponse = {\n  acceptedCount?: number\n  jobIds?: string[]\n}\n\ntype InboxClientProps = {\n  ssrBootstrap: InboxBootstrap | null\n}\n\nfunction useDebouncedValue<T>(value: T, delayMs: number): T {\n  const [debounced, setDebounced] = React.useState(value)\n\n  React.useEffect(() => {\n    const timeout = window.setTimeout(() => {\n      setDebounced(value)\n    }, delayMs)\n\n    return () => {\n      window.clearTimeout(timeout)\n    }\n  }, [delayMs, value])\n\n  return debounced\n}\n\nfunction parseInitialTab(input: string | null, fallback: InboxTab): InboxTab {\n  if (input === \"pending\" || input === \"replied\" || input === \"all\") return input\n  return fallback\n}\n\nfunction parseInitialRating(input: string | null): string {\n  if (!input) return \"all\"\n  const numeric = Number(input)\n  if (!Number.isFinite(numeric) || numeric < 1 || numeric > 5) return \"all\"\n  return String(Math.floor(numeric))\n}\n\nfunction InboxErrorFallback({ error, reset }: { error: Error; reset: () => void }) {\n  return (\n    <ErrorState\n      error={error}\n      title=\"Inbox failed to render\"\n      description=\"A runtime error occurred while loading this page.\"\n      onRetry={reset}\n    />\n  )\n}\n\nexport default function InboxClient({ ssrBootstrap }: InboxClientProps) {\n  return (\n    <ErrorBoundary fallback={InboxErrorFallback}>\n      <NotificationProvider>\n        <InboxClientBody ssrBootstrap={ssrBootstrap} />\n      </NotificationProvider>\n    </ErrorBoundary>\n  )\n}\n\nfunction InboxClientBody({ ssrBootstrap }: InboxClientProps) {\n  const searchParams = useSearchParams()\n  const { addNotification } = useNotifications()\n\n  const initialParams = React.useMemo(() => {\n    const filter = parseFilter(searchParams.get(\"filter\"))\n    const tabFallback: InboxTab = filter === \"all\" ? \"all\" : \"pending\"\n    const tab = parseInitialTab(searchParams.get(\"tab\"), tabFallback)\n\n    return {\n      filter,\n      tab,\n      mention: searchParams.get(\"mention\")?.trim().toLowerCase() ?? \"\",\n      locationId: searchParams.get(\"locationId\")?.trim() ?? \"\",\n      rating: parseInitialRating(searchParams.get(\"rating\")),\n    }\n  }, [searchParams])\n\n  const [bootstrap, setBootstrap] = React.useState<InboxBootstrap | null>(ssrBootstrap)\n  const [bootstrapLoading, setBootstrapLoading] = React.useState(ssrBootstrap === null)\n\n  const [baseFilter, setBaseFilter] = React.useState<ReviewFilter>(initialParams.filter)\n  const [activeTab, setActiveTab] = React.useState<InboxTab>(initialParams.tab)\n  const [mentionFilter, setMentionFilter] = React.useState(initialParams.mention)\n  const [locationFilter, setLocationFilter] = React.useState(initialParams.locationId || \"all\")\n  const [ratingFilter, setRatingFilter] = React.useState(initialParams.rating)\n  const [search, setSearch] = React.useState(\"\")\n  const [activeReviewId, setActiveReviewId] = React.useState<string | null>(null)\n  const [quickApproveLoadingId, setQuickApproveLoadingId] = React.useState<string | null>(null)\n  const [bulkApproveLoading, setBulkApproveLoading] = React.useState(false)\n\n  const debouncedSearch = useDebouncedValue(search, 300)\n\n  React.useEffect(() => {\n    if (ssrBootstrap !== null) return\n\n    setBootstrapLoading(true)\n\n    void (async () => {\n      try {\n        const params = new URLSearchParams({\n          filter: resolveRemoteFilter(initialParams.filter, initialParams.tab),\n          status: initialParams.tab,\n          includeCounts: \"1\",\n        })\n\n        if (initialParams.filter === \"mentions\" && initialParams.mention) {\n          params.set(\"mention\", initialParams.mention)\n        }\n        if (initialParams.locationId) {\n          params.set(\"locationId\", initialParams.locationId)\n        }\n        if (initialParams.rating !== \"all\") {\n          params.set(\"rating\", initialParams.rating)\n        }\n\n        const nextBootstrap = await apiCall<InboxBootstrap>(`/api/inbox/bootstrap?${params.toString()}`, \"GET\")\n        setBootstrap(nextBootstrap)\n      } catch (error) {\n        toast.error(error instanceof Error ? error.message : \"Failed to load inbox bootstrap\")\n      } finally {\n        setBootstrapLoading(false)\n      }\n    })()\n  }, [initialParams, ssrBootstrap])\n\n  const mentionKeywords = React.useMemo(() => {\n    return Array.from(\n      new Set(\n        (bootstrap?.mentionKeywords ?? [])\n          .map((keyword) => keyword.trim().toLowerCase())\n          .filter(Boolean),\n      ),\n    )\n  }, [bootstrap?.mentionKeywords])\n\n  React.useEffect(() => {\n    if (mentionFilter.trim() || mentionKeywords.length === 0) return\n    setMentionFilter(mentionKeywords[0])\n  }, [mentionFilter, mentionKeywords])\n\n  React.useEffect(() => {\n    if (baseFilter !== \"mentions\") return\n    if (mentionKeywords.length > 0) return\n    setBaseFilter(\"unanswered\")\n  }, [baseFilter, mentionKeywords.length])\n\n  const normalizedMention = mentionFilter.trim().toLowerCase()\n  const effectiveFilter = baseFilter === \"mentions\" && normalizedMention.length === 0 ? \"all\" : baseFilter\n  const remoteFilter = resolveRemoteFilter(effectiveFilter, activeTab)\n  const remoteStatus = activeTab\n\n  const queryMention = effectiveFilter === \"mentions\" ? normalizedMention || undefined : undefined\n  const querySearch = debouncedSearch.trim() || undefined\n  const queryLocation = locationFilter === \"all\" ? undefined : locationFilter\n  const queryRating = ratingFilter === \"all\" ? undefined : Number(ratingFilter)\n\n  const { rows, counts, loading, loadingMore, error, hasMore, loadMore, refresh, updateRow } = usePaginatedReviews({\n    filter: remoteFilter,\n    status: remoteStatus,\n    mention: queryMention,\n    search: querySearch,\n    locationId: queryLocation,\n    rating: Number.isFinite(queryRating) ? queryRating : undefined,\n    enabled: !bootstrapLoading,\n    initialPage: bootstrap?.initialPage ?? null,\n  })\n\n  const handleQueuedJob = React.useCallback(\n    (event: { jobId: string; reviewId: string; operation: \"generate\" | \"verify\" | \"publish\" }) => {\n      const title =\n        event.operation === \"generate\"\n          ? \"Draft generation queued\"\n          : event.operation === \"verify\"\n            ? \"Verification queued\"\n            : \"Reply publish queued\"\n\n      addNotification({\n        type: \"loading\",\n        title,\n        message: \"Tracking background job in real time.\",\n        jobId: event.jobId,\n        action: {\n          label: \"Open review\",\n          onClick: () => {\n            setActiveReviewId(event.reviewId)\n          },\n        },\n      })\n    },\n    [addNotification],\n  )\n\n  const { generateDraft, saveDraft, verifyDraft, publishReply } = useReviewMutations({\n    rows,\n    updateRow,\n    refresh,\n    onQueuedJob: handleQueuedJob,\n  })\n\n  const handleGenerate = React.useCallback(\n    async (reviewId: string) => {\n      await generateDraft(reviewId)\n    },\n    [generateDraft],\n  )\n\n  const handleSave = React.useCallback(\n    async (reviewId: string, text: string, options?: { silent?: boolean }) => {\n      await saveDraft(reviewId, text, options)\n    },\n    [saveDraft],\n  )\n\n  const handleVerify = React.useCallback(\n    async (reviewId: string) => {\n      await verifyDraft(reviewId)\n    },\n    [verifyDraft],\n  )\n\n  const handlePublish = React.useCallback(\n    async (reviewId: string, text: string, row: ReviewRow) => {\n      await publishReply(reviewId, text, row)\n    },\n    [publishReply],\n  )\n\n  React.useEffect(() => {\n    if (!error) return\n    if (error === \"mention is required when filter=mentions.\") {\n      toast.error(\"Pick a mention keyword before using the mentions queue.\")\n      return\n    }\n    toast.error(error === \"SESSION_EXPIRED\" ? \"Session expired. Please sign in again.\" : error)\n  }, [error])\n\n  const pendingCount = React.useMemo(\n    () => counts?.unanswered ?? rows.filter((row) => row.status === \"pending\").length,\n    [counts?.unanswered, rows],\n  )\n  const eligibleBulkRows = React.useMemo(() => rows.filter((row) => canBulkApprove(row)), [rows])\n\n  const activeFiltersCount =\n    Number(search.trim().length > 0) +\n    Number(baseFilter !== \"unanswered\") +\n    Number(locationFilter !== \"all\") +\n    Number(ratingFilter !== \"all\")\n\n  const clearFilters = React.useCallback(() => {\n    setSearch(\"\")\n    setBaseFilter(\"unanswered\")\n    setLocationFilter(\"all\")\n    setRatingFilter(\"all\")\n    if (mentionKeywords.length > 0) {\n      setMentionFilter(mentionKeywords[0])\n    }\n  }, [mentionKeywords])\n\n  const openReview = React.useCallback((reviewId: string) => {\n    setActiveReviewId((prev) => (prev === reviewId ? null : reviewId))\n  }, [])\n\n  const handleRefresh = React.useCallback(() => {\n    void refresh()\n  }, [refresh])\n\n  const handleQuickApprove = React.useCallback(\n    async (reviewId: string) => {\n      const row = rows.find((item) => item.id === reviewId)\n      if (!row?.currentDraft?.text?.trim()) {\n        toast.error(\"No verified draft to publish for this review.\")\n        return\n      }\n\n      setQuickApproveLoadingId(reviewId)\n      try {\n        await publishReply(reviewId, row.currentDraft.text, row)\n      } catch (error) {\n        toast.error(error instanceof Error ? error.message : \"Quick approve failed\")\n      } finally {\n        setQuickApproveLoadingId(null)\n      }\n    },\n    [publishReply, rows],\n  )\n\n  const handleBulkApprove = React.useCallback(async () => {\n    if (!bootstrap?.bulkApproveEnabled) {\n      toast.error(\"Bulk approve is disabled in organization settings.\")\n      return\n    }\n    if (eligibleBulkRows.length === 0) {\n      toast.error(\"No eligible 5-star, ready-draft reviews found on this page.\")\n      return\n    }\n\n    setBulkApproveLoading(true)\n    try {\n      const response = await apiCall<BulkApproveResponse>(\"/api/replies/bulk-approve\", \"POST\", {\n        reviewIds: eligibleBulkRows.slice(0, 50).map((row) => row.id),\n      })\n\n      const acceptedCount = response.acceptedCount ?? eligibleBulkRows.length\n      toast.success(`${acceptedCount} ${acceptedCount === 1 ? \"reply\" : \"replies\"} queued`)\n\n      if (response.jobIds?.[0]) {\n        addNotification({\n          type: \"loading\",\n          title: \"Bulk publishing queued\",\n          message: `${acceptedCount} replies are processing in the background.`,\n          jobId: response.jobIds[0],\n        })\n      }\n\n      void refresh()\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Bulk approve failed\")\n    } finally {\n      setBulkApproveLoading(false)\n    }\n  }, [addNotification, bootstrap?.bulkApproveEnabled, eligibleBulkRows, refresh])\n\n  const handleFilterChange = React.useCallback(\n    (next: ReviewFilter) => {\n      if (next === \"mentions\" && mentionKeywords.length === 0) {\n        toast.error(\"No mention keywords configured yet.\")\n        return\n      }\n      if ((next === \"unanswered\" || next === \"urgent\") && activeTab === \"replied\") {\n        setActiveTab(\"pending\")\n      }\n      setBaseFilter(next)\n    },\n    [activeTab, mentionKeywords.length],\n  )\n\n  const isFeedLoading = loading || bootstrapLoading\n\n  return (\n    <div className={INBOX_THEME_CLASSES.frame}>\n      <div className={INBOX_THEME_CLASSES.workspace}>\n        <section className={cn(INBOX_THEME_CLASSES.feedPane, \"w-full\")}>\n          <div className=\"flex h-full min-h-0 flex-col\">\n            <InboxHeader\n              pendingCount={pendingCount}\n              tab={activeTab}\n              onTabChange={setActiveTab}\n              search={search}\n              onSearchChange={setSearch}\n              refreshing={isFeedLoading}\n              onRefresh={handleRefresh}\n            />\n\n            <InboxFilterBar\n              filter={baseFilter}\n              onFilterChange={handleFilterChange}\n              mentionFilter={mentionFilter}\n              onMentionFilterChange={setMentionFilter}\n              mentionKeywords={mentionKeywords}\n              locationFilter={locationFilter}\n              onLocationFilterChange={setLocationFilter}\n              locations={bootstrap?.locations ?? []}\n              ratingFilter={ratingFilter}\n              onRatingFilterChange={setRatingFilter}\n              activeFiltersCount={activeFiltersCount}\n              onReset={clearFilters}\n              onBulkApprove={handleBulkApprove}\n              bulkApproveCount={eligibleBulkRows.length}\n              bulkApproveLoading={bulkApproveLoading}\n              bulkApproveEnabled={Boolean(bootstrap?.bulkApproveEnabled)}\n            />\n\n            <div className=\"min-h-0 flex-1\">\n              <InboxReviewList\n                activeTab={activeTab}\n                rows={rows}\n                activeReviewId={activeReviewId}\n                loading={isFeedLoading}\n                error={error}\n                hasMore={hasMore}\n                loadingMore={loadingMore}\n                showQuickApprove\n                quickApproveLoadingId={quickApproveLoadingId}\n                onOpenReview={openReview}\n                onQuickApprove={handleQuickApprove}\n                onGenerateDraft={handleGenerate}\n                onSaveDraft={handleSave}\n                onVerifyDraft={handleVerify}\n                onPublishReply={handlePublish}\n                onLoadMore={loadMore}\n                onRetry={handleRefresh}\n              />\n            </div>\n          </div>\n        </section>\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "path": "app/(app)/inbox/model.ts",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/model.ts",
      "bytes": 1905,
      "content": "import type { ReviewDetail, ReviewFilter, ReviewRow } from \"@/lib/hooks\"\nimport { mapReviewDetailToRow } from \"@/lib/reviews/detail-to-row\"\nimport { getFirstVerifierIssueMessage } from \"@/lib/reviews/verifier-result\"\n\nexport function parseFilter(input: string | null): ReviewFilter {\n  const value = (input ?? \"\").toLowerCase()\n  if (value === \"unanswered\" || value === \"urgent\" || value === \"five_star\" || value === \"mentions\" || value === \"all\") {\n    return value\n  }\n  return \"unanswered\"\n}\n\nexport function resolveRemoteFilter(baseFilter: ReviewFilter, tab: \"all\" | \"pending\" | \"replied\"): ReviewFilter {\n  if (tab === \"replied\") {\n    return baseFilter === \"unanswered\" || baseFilter === \"urgent\" ? \"all\" : baseFilter\n  }\n  if (tab === \"all\") {\n    return baseFilter === \"unanswered\" ? \"all\" : baseFilter\n  }\n  return baseFilter\n}\n\nexport function canBulkApprove(row: ReviewRow) {\n  return row.status === \"pending\" && row.starRating === 5 && row.draftStatus === \"READY\"\n}\n\nexport function initials(name: string) {\n  const parts = name.trim().split(/\\s+/).filter(Boolean)\n  const first = parts[0]?.[0] ?? \"?\"\n  const last = parts.length > 1 ? parts[parts.length - 1]?.[0] : \"\"\n  return (first + last).toUpperCase()\n}\n\nexport function mapDetailToRow(existing: ReviewRow, detail: ReviewDetail): ReviewRow {\n  return mapReviewDetailToRow(detail, existing)\n}\n\nexport function applyDetailSnapshot(\n  reviewId: string,\n  detail: ReviewDetail | null | undefined,\n  updateRow: (id: string, updater: (row: ReviewRow) => ReviewRow) => void,\n) {\n  if (!detail) return false\n  updateRow(reviewId, (row) => mapDetailToRow(row, detail))\n  return true\n}\n\nexport function getVerifierBlockedMessage(detail: ReviewDetail | null) {\n  const firstMessage = getFirstVerifierIssueMessage(detail?.currentDraft?.verifierResultJson ?? null)\n  return firstMessage ?? \"Draft was blocked by verifier. Please adjust and retry.\"\n}\n"
    },
    {
      "path": "app/(app)/inbox/network.ts",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/network.ts",
      "bytes": 10509,
      "content": "import { withIdempotencyHeader } from \"@/lib/api/client-idempotency\"\nimport { extractClientErrorMessage } from \"@/lib/api/client-error\"\n\nimport type { ReviewDetail } from \"@/lib/hooks\"\n\nconst JOB_POLL_BASE_MS = 900\nconst JOB_POLL_MAX_MS = 2600\nconst JOB_SSE_MIN_BUDGET_MS = 900\nconst JOB_SSE_MAX_BUDGET_MS = 12_000\nconst JOB_SSE_CLOSE_GRACE_MS = 1_250\nconst JOB_TERMINAL_CACHE_TTL_MS = 15_000\nconst JOB_TERMINAL_CACHE_MAX_ENTRIES = 512\nconst REVIEW_POLL_INTERVAL_MS = 650\n\ntype JobStatus = \"PENDING\" | \"RUNNING\" | \"RETRYING\" | \"COMPLETED\" | \"FAILED\" | \"CANCELLED\"\n\ntype JobDetail = {\n  id: string\n  type: string\n  status: JobStatus\n  attempts: number\n  maxAttempts: number\n  runAtIso: string\n  lockedAtIso: string | null\n  completedAtIso: string | null\n  lastError: string | null\n  retryAfterSec?: number | null\n}\n\ntype JobStatusResponse = {\n  job: JobDetail\n}\n\ntype JobStreamEvent = {\n  kind: \"snapshot\" | \"transition\" | \"terminal\"\n  job: JobDetail\n  review?: ReviewDetail | null\n}\n\ntype JobStreamTimeoutEvent = {\n  kind: \"timeout\"\n  job: JobDetail | null\n}\n\ntype TerminalJobCacheEntry = {\n  job: JobDetail\n  expiresAt: number\n}\n\nexport type JobCompletionResult = {\n  job: JobDetail\n  review: ReviewDetail | null\n}\n\nconst terminalJobCache = new Map<string, TerminalJobCacheEntry>()\nconst inflightJobDetailRequests = new Map<string, Promise<JobDetail | null>>()\nconst JOB_STATUS_VALUES = new Set<JobStatus>([\"PENDING\", \"RUNNING\", \"RETRYING\", \"COMPLETED\", \"FAILED\", \"CANCELLED\"])\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction isTerminalJobStatus(status: JobStatus) {\n  return status === \"COMPLETED\" || status === \"FAILED\" || status === \"CANCELLED\"\n}\n\nfunction trimExpiredTerminalCache(now: number) {\n  for (const [key, value] of terminalJobCache.entries()) {\n    if (value.expiresAt <= now) {\n      terminalJobCache.delete(key)\n    }\n  }\n}\n\nfunction getCachedTerminalJob(jobId: string): JobDetail | null {\n  const now = Date.now()\n  const cached = terminalJobCache.get(jobId)\n  if (!cached) return null\n  if (cached.expiresAt <= now) {\n    terminalJobCache.delete(jobId)\n    return null\n  }\n  return cached.job\n}\n\nfunction cacheTerminalJob(job: JobDetail) {\n  if (!isTerminalJobStatus(job.status)) return\n\n  const now = Date.now()\n  trimExpiredTerminalCache(now)\n  terminalJobCache.set(job.id, { job, expiresAt: now + JOB_TERMINAL_CACHE_TTL_MS })\n  while (terminalJobCache.size > JOB_TERMINAL_CACHE_MAX_ENTRIES) {\n    const oldest = terminalJobCache.keys().next()\n    if (oldest.done) break\n    terminalJobCache.delete(oldest.value)\n  }\n}\n\nfunction resolveJobPollDelayMs(params: {\n  job: JobDetail | null\n  attempts: number\n  remainingMs: number\n}) {\n  const { job, attempts, remainingMs } = params\n  if (remainingMs <= 0) return 0\n\n  const retryAfterMs = Number(job?.retryAfterSec ?? 0) * 1000\n  if (Number.isFinite(retryAfterMs) && retryAfterMs > 0) {\n    return Math.min(remainingMs, Math.max(JOB_POLL_BASE_MS, Math.min(4_000, retryAfterMs)))\n  }\n\n  const status = job?.status\n  const computedDelay =\n    status === \"PENDING\"\n      ? JOB_POLL_BASE_MS + attempts * 260\n      : status === \"RUNNING\"\n        ? JOB_POLL_BASE_MS + attempts * 210\n        : status === \"RETRYING\"\n          ? JOB_POLL_BASE_MS + 450 + attempts * 320\n          : JOB_POLL_BASE_MS + attempts * 240\n\n  return Math.min(remainingMs, Math.max(JOB_POLL_BASE_MS, Math.min(JOB_POLL_MAX_MS, computedDelay)))\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null\n}\n\nfunction parseJobDetail(value: unknown): JobDetail | null {\n  if (!isRecord(value)) return null\n  const status = value.status\n  if (\n    typeof value.id !== \"string\" ||\n    typeof value.type !== \"string\" ||\n    typeof status !== \"string\" ||\n    !JOB_STATUS_VALUES.has(status as JobStatus)\n  ) {\n    return null\n  }\n  return value as JobDetail\n}\n\nfunction parseJobStreamEvent(data: string): JobStreamEvent | JobStreamTimeoutEvent | null {\n  try {\n    const raw = JSON.parse(data) as unknown\n    if (!isRecord(raw) || typeof raw.kind !== \"string\") return null\n\n    if (raw.kind === \"timeout\") {\n      const job = parseJobDetail(raw.job)\n      return { kind: \"timeout\", job }\n    }\n\n    if (raw.kind !== \"snapshot\" && raw.kind !== \"transition\" && raw.kind !== \"terminal\") {\n      return null\n    }\n\n    const job = parseJobDetail(raw.job)\n    if (!job) return null\n    const review = raw.review as ReviewDetail | null | undefined\n    return { kind: raw.kind, job, review }\n  } catch {\n    return null\n  }\n}\n\nfunction resolveSseBudgetMs(timeoutMs: number) {\n  if (timeoutMs <= 0) return 0\n  if (timeoutMs <= JOB_SSE_MIN_BUDGET_MS) return timeoutMs\n\n  const proportional = Math.floor(timeoutMs * 0.6)\n  return Math.min(timeoutMs, Math.max(JOB_SSE_MIN_BUDGET_MS, Math.min(JOB_SSE_MAX_BUDGET_MS, proportional)))\n}\n\nexport async function apiCall<T>(url: string, method: string, body?: unknown): Promise<T> {\n  const upper = method.toUpperCase()\n  const mutating = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"].includes(upper)\n  const baseHeaders = body ? { \"content-type\": \"application/json\" } : undefined\n  const headers = mutating ? withIdempotencyHeader(baseHeaders) : baseHeaders\n\n  const response = await fetch(url, {\n    method: upper,\n    headers,\n    body: body ? JSON.stringify(body) : undefined,\n  })\n\n  const data = await response.json().catch(() => null)\n  if (!response.ok) {\n    throw new Error(\n      extractClientErrorMessage({\n        body: data,\n        statusText: response.statusText,\n      }),\n    )\n  }\n\n  return data as T\n}\n\nexport async function fetchReviewDetail(reviewId: string): Promise<ReviewDetail | null> {\n  const response = await fetch(`/api/reviews/${reviewId}`)\n  if (!response.ok) return null\n  return (await response.json().catch(() => null)) as ReviewDetail | null\n}\n\nexport async function fetchJobDetail(jobId: string): Promise<JobDetail | null> {\n  const cached = getCachedTerminalJob(jobId)\n  if (cached) return cached\n\n  const inflight = inflightJobDetailRequests.get(jobId)\n  if (inflight) {\n    return inflight\n  }\n\n  const request = (async () => {\n    const response = await fetch(`/api/jobs/${jobId}`)\n    if (!response.ok) return null\n    const data = (await response.json().catch(() => null)) as JobStatusResponse | null\n    const job = data?.job ?? null\n    if (job) {\n      cacheTerminalJob(job)\n    }\n    return job\n  })()\n\n  inflightJobDetailRequests.set(jobId, request)\n  try {\n    return await request\n  } finally {\n    if (inflightJobDetailRequests.get(jobId) === request) {\n      inflightJobDetailRequests.delete(jobId)\n    }\n  }\n}\n\nasync function waitForJobCompletionViaSse(jobId: string, timeoutMs: number): Promise<JobCompletionResult | null> {\n  if (timeoutMs <= 0) return null\n  if (typeof window === \"undefined\" || typeof EventSource === \"undefined\") return null\n\n  const streamUrl = `/api/jobs/${encodeURIComponent(jobId)}/events?timeoutMs=${Math.floor(timeoutMs)}`\n\n  return new Promise<JobCompletionResult | null>((resolve) => {\n    const source = new EventSource(streamUrl)\n    let settled = false\n    let guardTimer: ReturnType<typeof globalThis.setTimeout> | null = null\n\n    const finish = (value: JobCompletionResult | null) => {\n      if (settled) return\n      settled = true\n      if (guardTimer != null) {\n        globalThis.clearTimeout(guardTimer)\n      }\n      source.close()\n      resolve(value)\n    }\n\n    const handleMessage = (data: string) => {\n      const parsed = parseJobStreamEvent(data)\n      if (!parsed) return\n\n      if (parsed.kind === \"timeout\") {\n        finish(null)\n        return\n      }\n\n      if (!isTerminalJobStatus(parsed.job.status)) {\n        return\n      }\n\n      cacheTerminalJob(parsed.job)\n      finish({\n        job: parsed.job,\n        review: parsed.review ?? null,\n      })\n    }\n\n    const onJob = (event: Event) => {\n      const message = event as MessageEvent<string>\n      handleMessage(message.data)\n    }\n\n    const onTimeout = (event: Event) => {\n      const message = event as MessageEvent<string>\n      const parsed = parseJobStreamEvent(message.data)\n      if (parsed?.kind === \"timeout\") {\n        if (parsed.job) {\n          cacheTerminalJob(parsed.job)\n        }\n        finish(null)\n        return\n      }\n      finish(null)\n    }\n\n    source.onmessage = onJob as (event: MessageEvent<string>) => void\n    source.addEventListener(\"job\", onJob)\n    source.addEventListener(\"timeout\", onTimeout)\n    source.onerror = () => {\n      finish(null)\n    }\n\n    guardTimer = globalThis.setTimeout(() => {\n      finish(null)\n    }, timeoutMs + JOB_SSE_CLOSE_GRACE_MS)\n  })\n}\n\nasync function waitForJobCompletionByPolling(jobId: string, timeoutMs: number): Promise<JobCompletionResult | null> {\n  if (timeoutMs <= 0) return null\n\n  const cached = getCachedTerminalJob(jobId)\n  if (cached) {\n    return { job: cached, review: null }\n  }\n\n  const startedAt = Date.now()\n  let attempts = 0\n\n  while (Date.now() - startedAt < timeoutMs) {\n    const job = await fetchJobDetail(jobId)\n    if (job && (job.status === \"COMPLETED\" || job.status === \"FAILED\" || job.status === \"CANCELLED\")) {\n      return { job, review: null }\n    }\n\n    const elapsedMs = Date.now() - startedAt\n    const remainingMs = timeoutMs - elapsedMs\n    const delayMs = resolveJobPollDelayMs({ job, attempts, remainingMs })\n    if (delayMs <= 0) break\n    await sleep(delayMs)\n    attempts += 1\n  }\n\n  return null\n}\n\nexport async function waitForJobCompletion(jobId: string, timeoutMs: number): Promise<JobCompletionResult | null> {\n  if (timeoutMs <= 0) return null\n\n  const cached = getCachedTerminalJob(jobId)\n  if (cached) {\n    return { job: cached, review: null }\n  }\n\n  const startedAt = Date.now()\n  const sseBudgetMs = resolveSseBudgetMs(timeoutMs)\n  if (sseBudgetMs > 0) {\n    const streamed = await waitForJobCompletionViaSse(jobId, sseBudgetMs)\n    if (streamed) {\n      return streamed\n    }\n  }\n\n  const elapsedMs = Date.now() - startedAt\n  const remainingMs = timeoutMs - elapsedMs\n  if (remainingMs <= 0) return null\n\n  return waitForJobCompletionByPolling(jobId, remainingMs)\n}\n\nexport async function waitForReviewState(\n  reviewId: string,\n  predicate: (detail: ReviewDetail) => boolean,\n  timeoutMs: number,\n) {\n  const startedAt = Date.now()\n\n  while (Date.now() - startedAt < timeoutMs) {\n    const detail = await fetchReviewDetail(reviewId)\n    if (detail && predicate(detail)) {\n      return detail\n    }\n    await sleep(REVIEW_POLL_INTERVAL_MS)\n  }\n\n  return null\n}\n"
    },
    {
      "path": "app/(app)/inbox/page.tsx",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/page.tsx",
      "bytes": 2124,
      "content": "import InboxClient from \"./InboxClient\"\nimport { parseFilter, resolveRemoteFilter } from \"./model\"\nimport { fetchInboxBootstrap } from \"@/lib/reviews/bootstrap\"\nimport { getSession } from \"@/lib/session\"\n\nimport type { InboxBootstrap } from \"./types\"\n\nexport default async function InboxPage({\n  searchParams,\n}: {\n  searchParams: Promise<Record<string, string | string[] | undefined>>\n}) {\n  const params = await searchParams\n  const session = await getSession()\n\n  let ssrBootstrap: InboxBootstrap | null = null\n\n  if (session?.orgId) {\n    try {\n      const rawFilter = typeof params.filter === \"string\" ? params.filter : null\n      const rawTab = typeof params.tab === \"string\" ? params.tab : null\n      const rawMention = typeof params.mention === \"string\" ? params.mention.trim().toLowerCase() : \"\"\n      const rawLocationId = typeof params.locationId === \"string\" ? params.locationId.trim() : \"\"\n      const rawRating = typeof params.rating === \"string\" ? params.rating : null\n\n      const filter = parseFilter(rawFilter)\n      const derivedTab = filter === \"all\" ? \"all\" : \"pending\"\n      const tab =\n        rawTab === \"pending\" || rawTab === \"replied\" || rawTab === \"all\" ? rawTab : derivedTab\n\n      const effectiveFilter = filter === \"mentions\" && rawMention.length === 0 ? \"all\" : filter\n      const remoteFilter = resolveRemoteFilter(effectiveFilter, tab)\n      const remoteStatus = tab\n      const remoteMention = effectiveFilter === \"mentions\" ? rawMention || undefined : undefined\n\n      const ratingNum = rawRating ? Number(rawRating) : undefined\n      const validRating =\n        ratingNum && Number.isFinite(ratingNum) && ratingNum >= 1 && ratingNum <= 5\n          ? Math.floor(ratingNum)\n          : undefined\n\n      ssrBootstrap = await fetchInboxBootstrap({\n        orgId: session.orgId,\n        filter: remoteFilter,\n        status: remoteStatus,\n        mention: remoteMention,\n        locationId: rawLocationId || undefined,\n        rating: validRating,\n        includeCounts: true,\n      })\n    } catch {\n      ssrBootstrap = null\n    }\n  }\n\n  return <InboxClient ssrBootstrap={ssrBootstrap} />\n}\n"
    },
    {
      "path": "app/(app)/inbox/types.ts",
      "absolutePath": "/Users/amankumarshrestha/LapenInns Project/googlereview/app/(app)/inbox/types.ts",
      "bytes": 751,
      "content": "import type { ReviewDetail, ReviewFilter } from \"@/lib/hooks\"\nimport type { ReviewListPage } from \"@/lib/reviews/types\"\n\nexport type LocationOption = {\n  id: string\n  displayName: string\n}\n\nexport type InboxBootstrap = {\n  mentionKeywords: string[]\n  bulkApproveEnabled: boolean\n  locations: LocationOption[]\n  initialPage: (ReviewListPage & {\n    filter: ReviewFilter\n    status?: \"pending\" | \"replied\" | \"all\"\n    mention?: string | null\n  }) | null\n}\n\nexport type ReviewMutationResponse = {\n  accepted?: boolean\n  jobId?: string\n  verifyJobId?: string\n  job?: {\n    id: string\n    status: \"PENDING\" | \"RUNNING\" | \"RETRYING\" | \"COMPLETED\" | \"FAILED\"\n    lastError?: string | null\n  }\n  worker?: { claimed?: number }\n  review?: ReviewDetail | null\n}\n"
    }
  ]
}
